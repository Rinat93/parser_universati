                                          Сообщество IT-специалистов
Ответы на любые вопросы об IT                            Профессиональное
развитие в IT                            Удаленная работа для IT-специалистов
Мегапосты:     The Standoff: шоу[https://u.tmtm.ru/pt_top]     Про умные
устройства[https://u.tmtm.ru/Smart_dev_rez_top]     Пока все
дома[https://u.tmtm.ru/bezopasno-daleko]   0xd34df00dвчера в 19:12




Пора на свалкуНикогда не думал, что это случится со мной, но, похоже, я
выгорел. А ещё мне стрёмно. Да, это ещё одна статья про выгорание.Я тут на днях
смотрел на свою RSS-читалку и заметил, что под тегом «C++» у меня где-то три
сотни непрочитанных статей. Я не прочитал ни одной статьи по плюсам с прошлого
лета, и мне офигенно. Я не написал ни строчки осмысленного кода на плюсах за
последние три месяца, с тех пор, как распустили отдел, где я работал, и мне
просто супер. Я позволил себе хотеть больше никогда не писать на плюсах, и у
меня появились крылья.Только стало страшно, потому что это давно уже стало
куском моей самоидентификации. Я писал на плюсах лет 17, это почти две трети
моей жизни, и как-то очень стрёмно всё это выкидывать. Всё моё сеньёрство-
помидорство, львиная часть моего опыта — она там, в наступании на плюсограбли.
Кто я без своего костюма?Короче, да, я выгорел. И я не знаю, что делать дальше.Я
очень люблю плюсы. Помню, как схомячил учебник Стивена Праты за неделю поездок в
школу в седьмом классе (ну хоть что-то хорошее от дороги в полтора часа в один
конец). Помню, как читал распечатку туториала по ACE (помнит ли сейчас кто-то
ACE?) на какой-то школьной экскурсии классе в девятом. Потом у меня появился
КПК, куда я мог залить chm'ку Саттера и читать её на пьянке у друга на даче
(куда меня почему-то больше не приглашали) классе в 11-м. Примерно тогда же я
уже и начал зарабатывать первые программистские деньги — снова спасибо плюсам.
Мои самые светлые воспоминания того периода — бессонные ночи и встречи рассвета
под чтение того же Саттера, Мейерса, Александреску, каких-то статей на RSDN, под
написание собственного кода. Я был наивным и не думал о будущем, но я ощущал,
что оно у меня есть, и что я его кую вот прямо сейчас. Что все эти бессонные
ночи и кодомарафоны на сутки и больше — это моё.Я люблю то время и благодарен
мирозданию за то, что оно у меня было.Но теперь пришла усталость.Просто надоело
ходить по минам. Нет, не по минному полю, а именно по минам, потому что на
минном поле есть участки без мин. 17 лет назад, когда я начинал, писать свой
вектор было весело и прикольно, и я мог это сделать за полчаса, а сейчас мне
нужно несколько дней и постоянная консультация со стандартом. Тварь я дрожащая
или право имею? Получу UB тут или нет? А тут? А тут? Да что там вектор, мы не
так давно с khim[https://habr.com/ru/users/khim/] довольно долго обсуждали, как
написать строку, и едва смогли определиться с тем, каким может (или должен) быть
тип элементов строки, чтобы не было алиасинга.Просто надоело смотреть на чужие
культи. На моей позапрошлой работе они все были так молоды, вся жизнь впереди
хорошие чуваки, и они хорошо знают своё дело — data science, статистику,
предметную область, что угодно — но на плюсах они просто отстреливают себе ноги.
Тяжело смотреть. И это бессмысленно. Там не нужно то, что плюсы могут дать, там
не нужна высокая производительность (всё равно они пишут клей), не нужна
близость к железу. К счастью, очередной пришедший тимлид это понял и перевёл
всех на питон. Правда, тогда мне пришлось уйти, питон — не мой язык.А, да,
производительность — эту самую топовую производительность плюсы тоже не могут
дать.Сравнить два POD одним memcmp? Нельзя.  Использовать строки, где внутри
char*, не думая об алиасинге? Нельзя.  Передавать unique_ptr в функцию,
рассчитывая, что оверхеда не будет, как говорят из каждого утюга? Нельзя.
Написать свой вектор для trivially copyable/constructible/etc types, который бы
не рассчитывал на то, что компилятор вырежет часть необходимых по стандарту
вещей? Нельзя.  Вообще писать современный код, пытаясь при этом быть
идиоматичным, но не рассчитывая на то, что компилятор свернёт все эти слои
шаблонных конструкций? Нельзя.Нельзя. Нельзя. Нельзя. Спасибо, но рассчитывать
на достаточно умный компилятор приятнее в других языках.Что там ещё?
Автовекторизация? Держи карман шире! Даже в простейших случаях уровня
«пробежаться по строке и подсчитать количество вхождений символа» (ассоциации
подкидывают название файла laba1.cpp) рукописный ассемблер оказывается быстрее
того, что генерирует gcc -O3 -march=native с нестандартными расширениями и
дёрганьем интринсиков (а что остаётся от плюсов с интринсиками? шедулинг
регистров?). Незначительно, на 2-5%, но и я не спец в ассемблере на этом уровне.
Без интринсиков и оставаясь исключительно в рамках стандарта? Тогда проигрыш в
2-3 раза. Ладно, это с кодом, про это я скоро напишу отдельную статью.Даже
выделить место под тривиальный тип и выmemcpyть туда набор байт — нельзя без
дополнительных приседаний, лайфтайм так не начнётся. До C++20. В C++20 начнётся,
спасибо, починили, но когнитивная нагрузка языка от этого только
выросла.Когнитивная нагрузка вообще только вырастает, даже когда какие-то вещи
исправляют, потому что я же, мать его, специалист, я же должен знать, что
починили, когда починили, и как было раньше. Да и C++ хорош поддержкой легаси, а
это значит, что ты с этим легаси можешь встретиться. Например, в прошлом месяце
ко мне обратился приятель с вопросом о том, как что-то сделать в C++03.И эта
когнитивная нагрузка — она не потому, что задачи того требуют. Это не внутренняя
непосредственная сложность предметной области. Это просто, ну, так исторически
сложилось.Смотреть на трёхэтажные конструкции из костылей, кстати, тоже надоело.
Было 20 способов инициализации, добавили uniform initialization syntax, стал 21
способ инициализации, но это всё ещё недостаточно uniform, поэтому в C++20 мы
сделаем uniform из обычных круглых скобочек. Кстати, кто-нибудь сходу помнит
правила выбора конструкторов с initializer list? Что-то там про неявные
преобразования с потерей точности, но если значение известно статически, то…Я
постарался выработать правило — если мне сходу неочевидно, что код делает, если
мне приходится вспоминать стандарт, если я чувствую неуверенность, то не надо
так писать код. Поэтому у нас есть uniform initialization syntax, но я пишу
std::vector<int> foo(n, val), без всяких фигурных скобочек, потому что я не хочу
думать, как интерпретация зависит от определения n и val. И мне стыдно так
писать, потому что все посоны на раёне пишут посты в блогах, где всё красиво, с
фигурными скобочками, со всеми новыми финтами.То есть, конечно, кто-то может
сказать, что чего там эта неуверенность, надо просто код писать и оттачивать
навык. Но я не хочу оттачивать навык интерпретации талмуда на полторы тысячи
страниц. В других языках это не нужно, даже там, где монады и зигогистоморфные
препроморфизмы. Да и 10 лет назад я вполне успешно писал продакшен-код за живые
деньги на этих же плюсах, а опыта у меня было точно меньше. Значит, наверное,
дело таки не только во мне.Да и проблемы возникают не только у меня.А сколько
CVE и прочих уязвимостей и падений появилось из-за того, что где-то не так с
указателем поступили, где-то проверка не там была, где-то… Чёрт, как жаль, что я
не сохраняю эти вещи.Короче, это была усталость.Потом я понял, что мне страшно.
У меня развился паралич.Прошлым летом я устроился на совершенно шикарную работу,
моими коллегами были умные, шарящие люди, ежедневно читающие блоги плюсистов и
новые пропозалы в стандарт, обсуждающие на ланче что-то из программирования и
каких-то новых фишек, а не то, как они провели выходные или какие планы на
следующие. Для которых «так нельзя, это потенциальное UB» — не пустой звук, а
повод потратить два дня на реализацию фичи вместо двух часов и искренне
поблагодарить меня, что я обратил внимание. Но даже они делали ошибки. Я делал
ошибки. Мы все делали ошибки. Они не знали то, что я считал базовыми знаниями. Я
не знал то, что они считали базовыми знаниями. Никто ничего не знает. Если они
не могут, то кто может?Мне страшно. Мне хочется забиться в угол и плакать. Я не
могу быть уверенным как минимум в половине строк, что я пишу. У меня есть
чувство, что я строю фекалодендритные конструкции, а убеждение хотя бы самого
себя в том, что написанное имеет смысл, занимает неоправданно много времени. Что
бы я ни делал, в моём коде будут UB. Я ни на что не могу повлиять. Психологи
говорят, что выученная беспомощность тут где-то рядом, так что написание кода на
плюсах для психики не очень полезно.Иронично, что больше всего уверенности у
меня в наименее нужных в среднем продакшен-коде вещах — что-то там на темплейтах
этакое намутить, на constexpr вот. Может, это потому, что вся эта мета-ерунда
куда ближе к так близкому сердцу принципу «если оно компилируется, то оно
работает».А, кстати о темплейтах. Рабочий проект, где каждый .cpp-файл
компилируется по 5-7 минут даже без оптимизаций? Время до первой диагностики
компилятора в те же 5 минут? Пердёж компилятора на десятки мегабайт в случае
ошибок? Да, я сохранял в файл и замерял ради интереса. Потребление памяти
компилятором в 5-10 гигов на файл? Билдсервер с 32 ядрами и 64 гигами памяти, на
которой нельзя запускать больше чем этак 8 параллельных потоков компиляции?
Проект на несколько десятков kloc, собирающийся на ней полчаса? Получите,
распишитесь.И тулинг. Мне куда проще находить, на что у меня тратится память, в
том же хаскеле, который, как известно, только для факториалов и годится. Системы
сборки? Ха. Апгрейд компилятора для прода? Жди лет пять после релиза стандарта.
Пакетный менеджер? Ха-ха. Reproducible builds? Ха-ха-ха. Все места, где я
работал, на это либо вообще забивали, либо вкладывали какое-то совершенно
неадекватное количество ресурсов. Я понимаю, почему так происходит, у этого
всего есть абсолютно логичные и объективные причины, по-другому и выйти не
могло, но я устал так жить.Это был страх от языка, но я пропустил его через
себя. Три месяца назад меня уволили, я пришёл домой, расслабился, вот уже три
месяца пишу код для себя (не на плюсах!), сделал пару мелких проектов и начал
один покрупнее, и мне хорошо.Было хорошо.Совсем недавно я поймал и осознал страх
другого рода, куда более экзистенциальный.Кто я такой? Я программист на плюсах.
Я пишу код на плюсах две трети жизни. Это действительно стало огромной частью
моей самоидентификации. Почему я претендую на синиора? Потому что я успел
отстрелить себе миллион ног и натаскать свою нейросеть в черепушке определять,
какая нога отстрелена на этот раз, по отсвету дульной вспышки. Потому что все
интервью, касающиеся языка, я проходил, как тут говорят, with flying colors.
Потому что я могу даже не готовиться к интервью, и всё равно его пройду. Потому
что я могу показать особо интересные куски кода на гитхабе, и для меня скипнут
как минимум телефонное интервью, а иногда скипали и техническое собеседование,
разговаривая только о жизни или в лучшем случае о дизайне систем, релевантных
для места работы.А так придётся выкидывать весь этот опыт в корзину и начинать
почти с нуля. Ну, да, у меня есть какое-то там системное мышление, я дизайнил
компиляторы, я дизайнил распределённые системы с противоречивыми требованиями,
это, наверное, тоже кусок синьористости, но если меня разбудить ночью и спросить
«почему ты претендуешь на синьора», я отвечу «потому что сиплюсплюс». Ко мне
обращаются коллеги, когда там какой-то адовый баг или что-то не работает или
надо что-то сделать на темплейтах или хорошее код-ревью бы. Это давно уже так —
помню, ещё где-то на третьем курсе, когда я отрабатывал пропуски по физкультуре
заплывами в бассейне, ко мне подплыл какой-то чувак и спросил: «а это ты
0xd34df00d? у меня тут вопрос по boost…»Это просто прорва времени и сил, которая
выкидывается вникуда. Это непереносимый опыт (каламбур, ага).Ну вот пойду я
сейчас собеседоваться на чистого хаскелиста какого-нибудь, или вообще в ресёрч.
Что я там скажу? На кого вообще претендовать? На каком основании? Что-то там
типы что-то там алгебра что-то там математика. Но разве это сравнится по
сложности со стандартом плюсов? Разве сравнятся мои тамошние навыки с моим
опытом в плюсах? 17 лет плюсов против этак лет 8-10 хаскеля. Против этак лет
трёх какой-то математики (примат в вузе не считается).Кто я, если выкинуть
плюсы?И, может, выкидывать это всё — ошибка. Меня ждут минимум в двух очень
хороших местах, одно из них неплохо смотрится в резюме, в обоих местах готовы
платить какие-то баснословные деньги, но просто не могу больше этим заниматься.
Кто-то наверняка скажет, что я с жиру бешусь, особенно сейчас, когда
неопределённость на рынке труда повыше. Наверное, кто-то будет прав.Короче, да,
мне немного страшно, и я устал. Я немножко стал динозавром. Когда-то я
непонимающе смотрел на людей, которые в гробу видали все новые вещи, а теперь я
замечаю что-то похожее в себе. Я не нахожу в себе силы читать новые вещи о C++,
и только о C++. За последние полгода я поковырял и неплохо проработал два новых
для меня языка, я ежедневно либо читаю всякие матанокнижки либо решаю задачки,
мой текущий проект — игрушечный proof-of-concept-язык, но меня тошнит при одной
мысли о том, чтобы прочитать ещё один пропозал или даже ещё одну пережёванную
статью-рерайт cppreference о каких-нибудь нововведениях в C++20.Собственно,
сначала я думал назвать эту статью «я стал динозавром», но проблема в другом. Те
люди — они, кажется, вполне себе счастливы на своём C++03 или C99, или где там у
них произошла кристаллизация, а я никак не счастлив и там. Проблема в том, что,
получается, моему опыту, моим навыкам, вот этому всему — этому пора на свалку. А
если этому пора на свалку, то не пора ли и мне?И да, я ни в коем случае не хочу
сказать, что плюсы — отстой. Вовсе нет, плюсы прекрасны, это я устал и кончился.
Проблема не в тебе, проблема во мне.Укажите причину минуса, чтобы автор
поработал над ошибками                               Метки лучше разделять
запятой. Например: программирование, алгоритмыУ нас было несколько ЦОДов в
разных городах, узкий канал связи и 2 месяца на переезд Как мы
выкрутились?[https://u.tmtm.ru/fnc_zaglushka]


         Редакторский дайджест       

         Присылаем лучшие статьи раз
в месяц                Скоро на этот адрес придет письмо. Подтвердите подписку,
если всё в силе.       +196989830k337               Поделиться
Скопировать ссылку                             Указан только блог
Орфографические ошибки                               Пунктуационные ошибки
Отступы                               Текст-простыня
Короткие предложения                               Смайлики
Много форматирования                               Картинки
Ссылки                               Оформление кода
Рекламный характер         Опишите суть нарушенияПлатежная система

Похожие
публикации

8 марта 2016 в 14:48

                   


+8                 +8                   16,8k                 16,8k
23                 23224 ноября 2015 в 14:12

                   


+13                 +13                   8k                 8k
6                 6920 августа 2011 в 23:26

                   


+76                 +76                   64,3k                 64,3k
149                 149302

              

                                от
40 000                                               до 150 000
от 40 000                                до 150 000
LoftschoolМожно удаленно                                от 30 000
до 50 000                                           от 30 000
до 50 000               Альфа БанкМосква                                от
100 000                                               до 300 000
от 100 000                                до 300 000               ЯндексМосква
от 100 000                                               до 300 000
от 100 000                                до 300 000               ЯндексМосква
до 70 000                                           до 70 000
DigitalWandКраснодарAdBlock похитил этот баннер, но баннеры не зубы — отрастут
Подробнее[https://u.tmtm.ru/tmtalkadblock]

         Комментарии         


337         jreznot+30xd34df00d+20Зря зачеркнули.Gorthauer87+9Так и в чем
проблема идти в Rust? Я ни секунду не жалею об этом выборе. Хотя до этого на
плюсах писал лет 8. Но от перехода не было даже никакого экзистенциального
кризиса, только пара месяцев ломки по некоторым паттернам.  Зато вот теперь
смотрю на плюсы и ощущаю что то похожее на то, что ты описываешь, но уже смотрю
со стороны на все это, это уже не часть меня больше. 0xd34df00d+7Rust — хороший
язык. Но проблемы есть.Хотя, конечно, раст наиболее близок к железу среди прочих
языков. Но всегда можно заниматься компиляторами этих самых прочих
языков.Gorthauer87+5Ну я прошел через этот путь, но не так уж это выкидывание
страшно, это все равно что избавится от legacy, это на самом деле крутое
ощущение, ты будто бы с нуля все делаешь и учишься.  Я вот в конце концов тоже
из родного окружения C++/Qt ушел в неизвестность blockchain разработки. А сейчас
еще и просто стало много вакансий в области системной разработки на расте,
причем именно в штатах. В России то пока немного тухляк, увы. 0xd34df00d+1Зря я
от одних идрисистов-блокчейнеров отказался с полгода назад,
похоже.Ft_iv+1middle+27vsb+5На мой взгляд это не выкидывание опыта. Rust молодой
язык и явно не для начинающих. Думаю, подавляющее число программистов на нём как
раз бывшие C++-ники. Т.е. вы будете вариться ровно в той же среде и
собеседование будете проходить возможно на том же С++. Но чем больше вы ждёте,
тем дальше эти группы будут расходиться и тем менее важным будет ваш
опыт.AnthonyMikh0Забавно, я слышал про Rust жалобы ровно противоположного
характера: мол, среди растоманов програмистов на Rust дофига выходцев из
Javascript, Python и Ruby.domix320Вероятно человек не трогал раст со времен
1.0blandger0Almet0ZaMaZaN4iK+65oclock0staticmain+270xd34df00d+17Безопасности там
ещё меньше, язык ещё многословнее и код на нём ещё менее поддерживаем. Некоторые
вещи (вроде тех, зачем были упомянутые шаблоны на 5-7 минут компиляции из поста)
на нём нереализуемы вообще никак, кроме кодогенерации. Собственно,
кодогенерировать его неплохо (хотя и это не всегда оптимальный вариант), писать
— пожалуй, воздержусь.А так можно и до ассемблера дойти, там нет 100% головной
боли, которую себе придумали в более высокоуровневых
языках.staticmain+100xd34df00d+15Ну да, чтобы писать код без багов, достаточно
просто 100%-ой концентрации 100% времени у 100% программистов, работающих над
проектом. Делов-то.Нормальный код на С будет куда многословнее нормального кода
на плюсах. Вам просто придётся куда больше читать.Нет, мне хочется не
этого.Представьте себе, что вы делаете фреймворк для построения графов обработки
данных (ну как gstreamer, если вам это о чём-то говорит). И представьте себе,
что вы хотите иметь минимальный рантайм-оверхед на всё это дело, потому что
десятки (а иногда и единицы) наносекунд конвертируются в прямую прибыль.Так вот,
в плюсах с темплейтами вы можете иметь статический полиморфизм (через CRTP) и
что-то вроде ООП, который в компилтайме компилятором разворачивается. И вместо
указателя на следующий узел в графе у вас параметр шаблона — тип объекта,
которому надо передать эти самые данные. Компилятор этот тип видит, он видит
вызываемую функцию, и может её подставить в точку вызова, избежав оверхеда от
вызова функции, добавив возможность последующих оптимизаций после инлайнинга, и
так далее.Более того, так как граф строится на этапе компиляции, вы можете на
этом же этапе делать всякие оптимизации. Например, копировать данные только
тогда, когда у одного source'а больше одного sink'а, и хотя бы один из этих
sink'ов меняет данные. Или, например, можете проверки делать, что граф вообще
имеет смысл.Как это сделать на С с такими же характеристиками
производительности?У меня на работе было достаточно проектов, чтобы заметить,
что корреляция понятности с языком в лучшем случае отсутствует. В худшем —
примеры лапшекода на С с функциями на тыщу-другую строк и управлением через
goto, у меня тоже есть. Но компилируется быстро, это факт.staticmain+3То есть вы
сравниваете откровенный говнокод на С со структурированным С++ и заявляете, что
С-плохой? Почему такой код попал в репозиторий проекта? У вас нет ревью кода?
Бегите оттуда.0xd34df00d+7Ну так с тем вашим проектом на плюсах точно то же
самое.Кстати, вопрос про то, как сделать ту штуку с графами на С, был абсолютно
серьёзным, мне это правда интересно.staticmain0Без понятия, какую задачу вы
решаете, но звучит так, как будто вам подойдет таблица коллбеков и что-то, что
будет хранить последовательность индексов — список, файл, граф0xd34df00d+14То
есть, вы платите по вызову функции там, где раньше могли бы его не платить,
упускаете возможности для оптимизации из-за отсутствия инлайнинга этих функций,
и переносите в рантайм проверку осмысленности графа или (написанную иначе на
шаблонах/констекспрах, пусть и дико уродливо) оптимизацию типа того же
отсутствия излишних копирований, когда они не нужны.le1ic–3AnthonyMikh0Так
инлайнинг полезен не сам по себе (стоимость косвенного вызова редко становится
блокером производительности), а тем, что код собирается в одном месте и
компилятору даётся возможность оптимизировать его
дальше.dmitryrf+4snizovtsev00xd34df00d+3А кодогенератор на чём? И почему бы
генерировать не LLVM IR, скажем?Я, если честно, даже не представляю, как это
будет работать. Особенно если у вас что-то вродеТо есть, вы будете делать свой
язык? Это я люблю и готов делать за бесплатно, но зачем тут С?В этой задаче
баланс между latency и throughput очень сильно смещён в сторону
latency.billyevans+10xd34df00d+1По моим оценкам лучший способ сделать это на С —
не делать это на С, а кодогенерировать С.STL'ные контейнеры мягко скажем не
фонтан с точки зрения производительности, вполне разумное решение.Но вот какой-
нибудь std::find_if или std::enable_if вполне себе норм, они точно ничего не
аллоцируют.snizovtsev–1А нужна ли она здесь? Пока вы сжигаете месяцы на борьбу с
теорией типов и ограничениями компилятора, идеальная команда из сишника,
(пен)тестера, девопса и исследователя:Честно — ни разу не видел проекта, где всё
бы это было. Но даже часть из этого даст больше безопасности и стабильности, чем
языковые фишки.Т.е. всё таки реализуемы.PsyHaSTe+5Как по мне, безопасность
лишней не бывает. Особенно, когда она бесплатная. Как пример бесплатной
безопаности можно взять Maybe вместо "Любая ссылка может быть null". Абсолютный
зирокост, платите максимум столько же, чаще — меньше.Языковые фишки дадут вам
гарантии языка вместо варнинга, используют докер для песочницы, возьмут удобную
библиотеку для структурного логгирования (привет, cmake), ну и так далее.В 1970х
годах си действительно был прорывом, и по праву стал одним из популярнейших
языков. Но, я не понимаю — действительно все считают, что за 50 лет никто не
придумал ничего, что хоть в чём-то было бы лучше? А ведь если есть язык который
в чём-то лучше, а в остальном хотя бы не хуже, то тогда он уже имеет больше
смысла. Неужели си — это идеальный священный грааль, лучше которого никто ничего
не смог сделать?0xd34df00d+4Не надо там сжигать месяцы, в самом деле. Идеальный
типотеоретик делает это за три дня.И всё это каждый релиз!Вне языка.
Кодогенерировать С я могу хоть из хаскеля, хоть из питона, хоть из DSL'ей типа
Ragel'а. Когда вы пишете на Ragel, вы же не пишете на С?domix320Мне кажется вы
маленько не про ту безопасность подумали. Речь в первую очередь безопасность
доступа к памяти, когда несколько разных кусков программ имеют доступ только к
своей локальной памяти и shared-памяти тредов. Вероятность поймать висячие
указатели или словить утечку в Си на порядок выше. Выход за границы массивов
тоже. Собственно львиная доля CVE на этих штуках и строится. Поэтому стандартные
контейнеры плюсов довольно неплохо защищают от таких ошибок и не требуют
утраивания штата. ZSH_Fan00xd34df00d0Про дельфи уже за меня хорошо написали
тут[https://habr.com/ru/post/497114/#comment_21547736].F0iL+1VlK0Когда сломался
я, то оставил себе право на небольшие либы на чистом Си, и только в тех местах,
где нужны инструкции SIMD и почти-уже-ассемблер, и только до 10-20 тыс строк
кода.Но у меня было не только выгорание, но еще и хронические проблемы с руками
отчасти из-за многословности как чистого С89/С99, так и
С++.ilyawg0veselovi40Alexufo+10xd34df00d+1Я вообще ничего не делал, а по большей
части плыл по течению. По крайней мере, каких-то нетривиальных решений я не
принимал. Делал либо то, что было интересно и драйвово (вот эти вот ночи за
кодом), либо то, что делают «все» и что делать «хорошо» ­(поступить в вуз,
написать диплом, принять вкусный оффер, пойти в аспирантуру, впрочем, успешно её
провалив).Но это уже совсем другая тема и совсем другая история.13x18+1tagirb+9У
меня похожая история: IT-кружок, отличник-медалист, универ, аспирантура, ктн,
стажировка за границей, карьера.Зациклился изначально на своей работе и её
оценке окружающими, идентифицировал себя с ней, стремился быть успешным всегда и
везде. Внешне "душка", внутри — махровый эгоист.После нескольких подзатыльников
от жизни стал задумываться: "А что же, собственно, не так, я же весь такой
хороший и всё, вроде бы, делаю правильно?"Ну и так постепенно стал оглядываться
по сторонам, понял, что свет клином не сошёлся на мне и моей работе, что вокруг
прекрасный мир и замечательные люди, начал думать о них, а не о себе и своих
проблемах. Помогать, любить, благодарить и всё время поддерживать внутренний
позитив.И вот реально вижу, как мне становится легче и проще. И как-то так пофиг
на все свои мелкие, букашечные проблемы, которые до того казались
вселенскими.LonelyDeveloper97+1Mnwamnowich+5AnthonyMikh+7Вставлю свои пять
копеек насчёт Rust:А, и половина отсутствующих в списке выше фич на самом деле
есть, но на ночной версии компилятора.И ещё кое-что, что уже не столь однозначно
плохо, но всё же заставит поломать голову при портировании архитектуры:А так —
да, неплохой современный язык, всем рекомендую.0xd34df00d0Ожидал по ссылке
typenum, навёл — увидел typenum в урле. Забавно, как в совсем разных языках
костыляются одни и те же вещи.Luchnik220Уже добавили в
RFC[https://github.com/rust-lang/rfcs/blob/master/text/2000-const-
generics.md#glossary]Одна из прелестей Rust в скорости его развития
обществомdefuz+1AnthonyMikh0"This is left as an exercise for reader."А если
серьёзно — если я сейчас начну всё это расписывать, то комментарий выйдет раза в
два больше, даже если я не буду упоминать библиотеки.frol0Прекрасный список!
Большинство из перечисленного в той или иной степени готовности или
запланированности и это само по себе здорово! Над всем перечисленным можно
поработать и при этом код нужно будет писать на Rust — вот он dog-
fooding.PsyHaSTe0GAT крайне сырой, специализация падает с ICE стоит чуть-чуть
отойти от примеров из issue, конст-генерики тоже, отлажены только сценарии
которыми пользуется кортима,… Так что степень запланированности тут весьма
условная. Что поделать — у кортимы нет ресурсов, все силы брошены на сахарный
асинк-авейт и залатывание дыр в пине. Приоритеты конечно вызывают грустное
удивление, но тут мало чего можно сделать.0xd34df00d+1А это норма. В хаскеле вон
сейчас тоже пытаются напихать всякого побыстрее. Некогда думать о том, как потом
сделать завтипы консистентными, давайте просто поскорее добавим П-байндеры!Эх,
где этот avoid popularity at all costs.PsyHaSTe0Да, понимаю. Те же чувства про
раст сейчас.DaylightIsBurning0Rust 2, Haskel 2. Все любят приводить пример
питона как негативный, а по мне, так это успех! Стратегические цели развития
языка важны, но полностью игнорировать тактические потребности пользователей
языка нельзя, иначе ресурсов не хватит довести разработку до пригодного для
использования состояния. Все эти популярные асинки нужны для того что бы
привлечь ресурсы в экосистему для больших вещей. Да, потом за это придется
платить, но хотя бы будем чем платить.frol+2async-await разблокировал гораздо
больше людей, чем блокирует GAT, на мой взгляд. Каждый год проводится
планирование и обсуждение приоритетов с сообществом, всегда можно
поучаствовать.Gorthauer87+1Без GAT невозможно доделать async/await, он нужен для
трейтов, а то так и будем жить в куче. PsyHaSTe+1По поим ощущениям async-await
сильно переоценен. Мало того что он сожрал столько ресурсов, так он ещё и
нестабильный, шаг влево — ICE, шаг вправо — пины повылазили. Простой пример —
попробуйте рекурсивную async/await функцию написать (я пробовал когда писал
статьи про загрузку дерева комментариев). Сразу пины-боксы, всё вот это
вылезает.У нас в проде щас крутится сравнительно большой микросервис на расте, с
актиксом, асинхронностью и прочим. И мы асинк-авейтом сознательно не пользуемся.
И знаете, у нас нет никакой лапши или проблем из-за этого. А вот конст генерики,
гаты и специализация без паник в компиляторе пригодились бы куда сильнее.Да не
особо. Помнится, большинство людей было против "?" оператора, но тима сказал
"нам плевать, мы считаем что так лучше". Ну и правы оказались, конечно. Они
вообще часто правы, но не всегда. Но поинт в любом случае в другом: мнение
сообщества учитывается, но не более того. Где-то читал прямую речь от лодочника
или ещё кого-то из главных чуваков, что мы сами принимаем решения. По-моему
после обсуждения асинк-авейта как раз, но уже точно не помню.An_Owl_or_not0Автор
знает Rust. Вот например упоминание в другой ветке: https://habr.com/ru/post/497
114/#comment_21547706[https://habr.com/ru/post/497114/#comment_21547706]0xd34df0
0d0Я про него слышал, и достаточно писал на хаскеле, чтобы мапить достаточную
часть растовских концепций на привычные мне. Но знанием это назвать вряд ли
можно.An_Owl_or_not+1Хм, извиняюсь. Мне казалось я видел как ты где-то делал
примеры кода на расте… Наверное перепутал с кем-то
другим0xf0a00+9ForNeVeR+5Дедфуду интересен подход, при котором «компилируется —
значит, работает», побольше всяких там компилтайм проверочек, побольше всего в
системе типов, побольше обоснованной уверенности в коде.Delphi, Pascal — ну
вообще не про это.tandzan0Akon320В Delphi свои проблемы. Большая часть из
которых решена в том же С++. 0xf0a000Akon32+3Отсыплю примерчиков.Как выглядит ФП
на современном делфи (да, я писал мини-библиотеку для всяких "нормальных" вещей
типа, хм, динамических массивов с capacity. TList сам ведь не
освобождается):Отмечу не только убогий автовывод (представьте вместо TA, TB
какой-нибудь TDictionary<SomeClass, TList>) типов, но и то, что подобный код
может криво подсвечиваться их же IDE, криво форматироваться их же IDE, а иногда
приводить к внутренним ошибкам компилятора. Для справки: IDE и компилятор
разрабатывает одна фирма.  Как выглядит тот же код на более хорошем языке:Таких
примеров кривости языка, даже не относящиеся к ФП, можно набрать минимум с
десяток.Ну взять хотя бы тот факт, что class, который с конструктором и
деструктором, всегда аллоцируется в куче, а record, который может содержать
конструктор с параметром, но не может содержать конструктор без параметров или
деструктор, всегда аллоцируется на стеке (или внутри class, record или массива).
При этом и в class, и в record поля определённых типов (интерфейсы, строки,
массивы) таки инициализируются и финализируются компилятором, т.е. конструкторы
по-умолчанию и деструкторы для record есть, но написать код для них язык не
позволяет. Поэтому RAII на record'ах (т.е., на стеке) реализовать невозможно. А
если использовать "более штатное" RAII на интерфейсах, addRef/releaseRef для
которых вызывается автоматически, то, во-первых, нужно писать отдельный
интерфейс для каждого класса, т.е. писать заголовки методов трижды (в
интерфейсе, в классе, в реализации), и, во-вторых, при создании объекта и
запросе интерфейса выделяются 2 области памяти в куче (что в некоторых случаях
приводило к просто эпической фрагментации виртуальной памяти). Ну ещё лишний jmp
при доступе к методам, но это уже можно не считать.А вот ещё. Уж не помню, есть
ли в delphi volatile переменные, но, когда я изучал этот вопрос (d7), такого
ключевого слова не было, и, по-видимому, все переменные были volatile. Впрочем,
для x86 это ничего не меняло. Ну либо все переменные были не volatile, но
многопоточность всё-таки работала, поэтому склоняюсь к первому варианту, хотя
достоверно не знаю. kryvichh0Беспараметровые конструкторы record уже на подходе.
Также должен появиться языковой сервер (?) в IDE, который через LSP (Language
Server Protocol) будет реализовывать подсветку и проч. ништяки в IDE.
Многословность дженериков ну да, есть такое. В некоторых диалектах Паскаля
(Oxygene) заимствовали синтаксис С#. Дельфисты же более консервативны в этом
плане.Akon320Ну наконец-то.  Но язык не идёт в ногу со временем.  inline var с
автовыводом вон тоже были "на подходе" аж до 2018 (?) года, когда уже и древние
С++, и Java давно осилили автовывод типов переменных.jack1280Непроходимо глючные
IDE и компилятор. Ребят, 10 лет как появились лямбды, в значения захваченные
переменные при отладке так и не показываются — это что? Выкатили inline variable
c выводом типов, но забыли, что managed-type нужно файнализировать? Один и тот
же код под Win64 выдает "[dcc64 Hint] Variable '' is declared but never used in
''", а под Win32 такого хинта нет?Неконсистентность, непоследовательность языка.
Почему дженереки не работают для свободных функций, где тайп хелперы для
джененик типов/интерфейсов, что за метания со способами управления памятью,
zero/one based strings и т.д. Такое очущение, что ребята не знают куда идти.
Сбоку фичу прикрутили и ладно.Как можно было сделать лямбды на подсчете ссылок и
при этом не дать возможность явно указывать список захватываемых переменных? В
результате одно неверное движение, получаем взаимные ссылки и мемлик. Одна из
базовых абстракций во всех языках — последовательность данных, итераторы. Взяли,
тупо скопировали из .NET. Только из-за различий в системе типов, в дельфи
иерархия IEnumerable/IEnumerable даже подстановку Лисков проваливает. Уж не
говоря о том, что из-за багов компилятора эти интерфейсы даже реализовать нельзя
нормально. :facepalm:  И так везде. Не, на времена Delphi5 — это был нормальный
язык. Но сейчас он сильно устарел с одной стороны, а попытки его подтянуть до
современного уровня больше похожи на костыли.Tyiler+80xd34df00d+3Ну почему, у
меня в жизни тоже много других вещей — вы абсолютно правы, не плюсами едиными.
Есть же хаскель, есть же математика!Gorthauer87+1Шутки ради swift умеет весьма
упоротые compile time штуковины, хотя конечно даже до раста ему далеко.
nikolayv810Дети это сплошной ub в недоверенной среде похлеще чем у js в IE при
этом на разогнанной процессоре на котором происходят ошибки в расчетах, с
постоянным состоянием гонки. Еду миллионами ппюроцессов, с околонулевой
изоляцией памяти, постоянными инъекциями как в код так и в данные при этом без
возможности перезагрузки и полного перехвата линий ввода —
выводаdeilux+1sshikov+30xd34df00d+6Я не понимаю, как это работает.То есть, у
меня на практике как-то задачи бизнеса всегда имели оговорки типа «у нас уже
есть система на плюсах, для которой нужно сделать новый компонент». Или «нужно
разработать новую систему, но её пользователями будут программисты на C++».
Наверное, дело в том, что я больше всего занимался чем-то вроде инфраструктурных
проектов.Ещё вот сейчас поймал себя на том, что не могу себе представить, для
какого рода задач можно иметь полную свободу выбора технологий без подобных
ограничений.Один из самых моих любимых примеров — один недокомилятор, что я
делал. Полностью вещь в себе, пользователи кормят ему описания каких-то правил и
получают какие-то обработчики этих правил. Но даже там надо было иметь плюсовые
обвязки, интегрироваться с кое-каким кодом на плюсах, и так далее.Ну или в
другом месте я очень много вспомогательных скриптов, каких-то анализаторов
данных, каких-то вычислительных экспериментов, всякое такое, в общем, делал на
хаскеле. Но основное ядро того, чем живёт бизнес, основной фреймворк для наших
клиентов (которые были программистами на плюсах из других отделов, так что мы
занимались инфрой по факту) — это всё равно были плюсы, и смена технологии не
обсуждалась. Даже несмотря на 5-7-минутные компиляции каждого файла,
неперевариваемые ошибки и всё такое. Максимум — начали немного разговаривать о
том, можно ли было бы туда вкрутить какой-нибудь DSL, чтобы пользователям было
не так больно этим фреймворком пользоваться.codecity+3sshikov00xd34df00d0А! Это
просто положительная обратная связь!Я хорошо могу в темплейты, относительно
неплохо могу в оптимизацию и language lawyer'изм. Поэтому меня зовут туда, где
это важно, и рассказывают другим знакомым обо мне (которым тоже, скорее всего,
важно это). И при этом я прокачиваю эти же навыки и становлюсь ещё лучше в этих
областях, в итоге меня туда же зовут охотнее. Круг
замкнулся.sshikov00xd34df00d0Ну я подправил резюме с упором на вот все эти
формальные вещи, ну или хотя бы просто ФП — что ты будешь делать, всё равно либо
всякое лоу-летенси на плюсах писать зовут, либо машинным обучением
заниматься.tester12+1sheshanaag0Система состоит из частей, и отдельные части
можно писать на любом языке, приклеивая их с помощью FFI, если язык это
поддерживает. Блюстители частоты могут даже не заметить, что внутри что-то не
сишное или не сплюсплюсное. TargetSan+16Как говорится, I feel your pain
bro.Хотел написать здесь длиннющую стену текста с собственным нытьём, но не буду
пожалуй. Просто скажу, что, начав очередной проект на С++, понял, что меня
просто-таки задолбало тратить неделю на сведение и настройку сборки нескольких
разношёрстных зависимостей. Тратить день на наладку тонкого патчинга одной из
них, чтобы она блин поддерживала хотя бы utf-8 пути для файлов.Я банально не
хочу заниматься в 500й раз этой рутиной. Я хочу решать задачу. Такие
дела.0xd34df00d0Вот да.Как же просто на других языках — появилась идея, ты
быстренько stack init, закидываешь в package.yaml зависимости какие надо, оно
там всё само билдится, и ты просто пишешь код.ZaMaZaN4iK00xd34df00d+1Неа[https:/
/habrastorage.org/webt/n9/-7/ty/n9-7ty78gasumaphsut8id-9ql8.png].Что у них за
сайт такой, кстати, что нельзя дать ссылку на результаты
поиска?ZaMaZaN4iK+10xd34df00d+3Так это частая ситуация. Я когда интересовался,
где есть наибольшая часть зависимостей одного моего плюсопроекта (для сборки под
винды) — оказалось, что msys2 всех заруливает.Дело ведь не в этом. Это всё
выбивает из контекста. В экосистеме A я просто дописываю пакет в список. В
экосистеме B я вижу, что его нет, начинаю пакетировать, начинаю париться с одной
из N систем сборок, которая, скорее всего, представляет тьюринг-полный язык и
используется в каждом проекте по-своему (можно сравнить с cabal/stack), в итоге
забываю напрочь про свою исходную задачу, о, кстати, надо почту проверить и чо
там на хабре в комментах.Плюс, в плюсовой культуре меньшее принятие мелких
utility-пакетов. Понятно, что до leftpad доходить тоже, наверное, не стоит, но
вот я сейчас открыл один из первых попавшихся под руку package.yaml — там есть
пакет ради функции uncurry3 :: a -> b -> c -> d -> (a, b, c) -> d с очевидной
семантикой, другой пакет для функции nubOrd :: Ord a => [a] -> [a], которая
оставляет только уникальные элементы в списке (понятно, что это пишется в три
строки с каким-нибудь std::set/std::unordered_set, но я не хочу это писать сто
раз), третий пакет для каких-то комбинаторов на Either, которые тоже пишутся в
три строки, но всё же.Ну вот почему всё в плюсомире как будто тебя немного
ненавидит?Я даже этот поиск еле нашёл, какой-то очевидной ссылки с conan.io туда
нет. Где-то там в подвале упомянуто про bincrafters. А я не знаю, что такое
bincrafters. Мне оно нужно? Или нужен какой-нибудь другой crafters?Если бы conan
был единственным де-факто менеджером зависимостей в плюсах, то эти вопросы были
бы чуть менее острыми — это был бы ещё один кусок знаний, которые просто все
должны изучить перед тем, как писать в прод. Но он не первый и, думаю, не
последний, так что заставлять изучать подобные вещи в момент выбора ПМа — ну так
себе идея, ИМХО.KanuTaH0ZaMaZaN4iK00xd34df00d0Вот взять бы C++20, выкинуть из
него всю фигню, починить нелогичности, и будет супер.Правда, увы, это получится
другой язык, которым плюсы никогда не будут.ZaMaZaN4iK0PsyHaSTe0И получили раст,
ага.Если что, неплохой доклад как выглядел раст в 2008
году[http://venge.net/graydon/talks/intro-talk-2.pdf] и какая у него была
мотивация. Сразу многие вещи про него становятся очевидными.TargetSan+1С одной
стороны де-факто стандарт это хорошо, с другой стороны я бы хотел что-то
поприличней.TargetSan0Классная штука, я оценил недавно. Особенно когда завезут
компоненты в полный рост. Проблема в укуренных скриптах сборки, которые надо
как-то с ним состыковать. Даже диалектов CMake выходит несколько
штук.lamerok+2Немного про сборку для срр проекта.  Как раз только на днях
закончили руководство по make для проекта :). Специально выделили человека на
месяц, чтобы он расписал для всех как эта хрень работает, и почему каждый раз,
когда мы её делаем для нового проекта, как будто все начинается заново.
Прикольно видеть всякие штуки типа, сокращения длины пути с пробелами на ~1 ~2 а
когда дойдет до 5, то вообще непонятно как, или ограничение на полный путь ко
всем исходникам в 8192 байта в винде, и мешанину из слешей аля path\dir/subdir/\
file.cppZaMaZaN4iK+2apxi–1TargetSan0Аргументируй.AdmAlexus+40xd34df00d+2В 11-12,
сейчас мне 29.А о детстве, по крайней мере, об этой его части вот вообще не
жалею, очень светлые воспоминания от него.scg+20xd34df00d0Но мне уже тогда
нравилось упарываться Александреску, и C++11 я очень-очень ждал. И ждал C++14,
17, да и 20 ждал. Но вот оказывается, что новые стандарты не отменяют старые
проблемы.scg+30xd34df00d+1Идея действительно шикарная, и она мне очень нравится
в некоторых других языках. Но проблема ещё и в том, что эту штуку практически
невозможно добавить в язык ретроактивно (как невозможно ретроактивно добавить
адекватную типизацию в динамически типизированный язык, или как невозможно
ретроактивно добавить зависимые типы в хаскель).codecity+60xd34df00d+2Ну я бы не
сказал, что желающих писать код на идрисе или агде прям так уж больше, чем на
плюсах.Тут какой-то не очень очевидный баланс между сложностью задач,
обоснованной сложностью используемых технологий, случайной сложностью
используемых технологий (вот она у плюсов зашкаливает), осмысленностью этих
самых задач (достаточно быстро перекладывать байтики я уже научился, до конца
жизни этим заниматься как-то скучновато), ну и ещё, конечно, сколько за всё это
платят (самые вкусные задачи в ресёрче, но и там же зарплаты меньше всего, если
область не хайповая).codecity0solver0В тегах f#… Это next big thing
?0xd34df00d+18Это поклон в сторону Мастера подобных постов.AnthonyMikh+12Это
очень тонкий троллинг одного совершенно конкретного
человека.noonv+40xd34df00d+5Именно потому, что я попробовал другие языки и
платформы, я и понял, насколько грустно всё с плюсами.DISaccount00xd34df00d+5А
мне вот не очень понятно, зачем в современном мире выбирать C++ как язык для
нового проекта, если не рассматривать факторы вроде «а у нас уже готовых
C++-программистов много» или «есть C++-библиотека, которая может помочь решить
нашу проблему, писать к ней биндинги долго».Либо я ваше настроение не так
распарсил.KanuTaH00xd34df00d0Дык проблема в том, что вот почему-то столкновений
с уже имеющимися проектами на C++ не
избежать.KanuTaH+1DISaccount00xd34df00d+6Жил-был один гусь, который наблюдал,
как других гусей на мясо пускают, но он-то каждый день просыпался живым и
здоровым, поэтому он решил, что это участь других гусей, а ему это не грозит.А
потом как-то раз его тоже на мясо пустили.А мода — дело такое. Я вот до сих пор,
считайте, ни строчки на расте не написал, или на Go.AnthonyMikh0Не
распространяйте дезинформацию[https://habr.com/ru/post/498042/#comment_21521010]
ZaMaZaN4iK00xd34df00d0А что этот бекенд делает? Если, условно, дёргает готовый
алгоритм поверх того же dlib или eigen — никаких
вопросов.ZaMaZaN4iK00xd34df00d0Ну фиг знает. Я бы это на хаскеле
делал.AnthonyMikh0Затем, что с помощью нового инструмента можно оказаться решить
задачу быстрее и проще, чем на C++.ZaMaZaN4iK+1AnthonyMikh0Безусловно, но если
не попробовать новый инструмент, то этого так и не узнать
наверняка.ZaMaZaN4iK00xd34df00d0А как компилятор инстансы для
парсинга/сериализации жсона выводит или код для работы с БД? Как сделать какой-
нибудь opaleye[https://hackage.haskell.org/package/opaleye] на
плюсах?ZaMaZaN4iK00xd34df00d+1Ну блин, с этим я при всём желании спорить не
могу.Но я так не могу. Как-то пытался ради интереса парсер на attoparsec'е
перевести на плюсы со спиритом — сдулся уже после потребности писать руками
операторы сравнения.Завезут в 23-м, до прода докатится в лучшем случае в 24-м, а
много где скорее в 27-м, и в итоге будем ещё 7 лет руками жсоны в структурки
перекидывать и обратно, и писать тесты, чтобы опечаток в имени полей не
было.Интересно, как часто люди выбирают std::set вместо std::unordered_set (ну и
с мапами аналогично) просто потому, что operator< уже написан, а хэш-функцию
писать лень?ZaMaZaN4iK0emdc0Далеко не факт. Если плюсы знаются хорошо и есть
опыт в подобных делах, то нет особых причин изучать другой инструмент: зачем
добавлять лаг обучения со сбором граблей (а они будут), когда можно просто сесть
и делать?ZaMaZaN4iK00xd34df00d0Потому что инструмент выбирается один раз, и лаг
происходит O(1) раз.KanuTaH00xd34df00d0Формально вы, конечно,
правы...PsyHaSTe0Мне кажется, разработчик должен стремиться к тому чтобы можно
было изучить любой инструмент за неделю… месяц. Тогда нет проблем — берешь
всегда самый подходящий. Я вот не понимаю, чего хорошего в том чтобы писать
руками (де)сериализатор или схему БД. KanuTaH0Речь скорее про это: "Я готов
выучить новый инструмент, если он будет решать задачи намного лучше те, которые
я делаю сейчас на С++, и при этом не будет ограничивать меня тем или иным в
других вещах, которые я также делаю на С++". Условно — да, какую-нибудь
сериализацию можно гораздо легче реализовать на каком-нибудь языке с рефлексией,
но… куда тогда девать тот же сборщик мусора, который мне там ну совершенно не
нужен? Особенно если эта сериализация — это 0.1% от общего объёма задачи.
VasyaTheBest+3UncleAndy0Gorthauer87+2Еще у языков и фреймворков есть своя
идеология или даже парадигма. И не все они чисто ментально нам подходят.  Грубо
говоря можно скакать между любыми языками с динамической типизацией, но
столкнуться с неприятием статической. akryukov+2Зачем вам вообще претендовать на
сеньора? Претендуйте на джуна, ну или на миддла. В нормальной организации время
само все расставит по местам. Можно ведь тихонечко сидеть "бухгалтером", время
от времени вытряхивать моль из своего костюма супермена и радоваться, что он
никому не нужен, потому что этому миру ничего не угрожает.  Возможно у вас еще
не было опыта потери чего-то важного. Ну что ж. С почином. Это не страшно.
Losing is fun(с)0xd34df00d0А фиг его знает, хороший вопрос.Наверное, дело в том,
что самооценка складывается не в последнюю очередь из фидбека от окружающих
людей, а такое изменение иррационально воспринимается как падение статуса, что
ли, даже тупо в своих глазах. Ну и зарплата, конечно, раз в 5 меньше — это уже
немного начинает быть аргументом даже для меня.akryukov+5Вся эта градация
senior-middle и т.п. в некоторой степени нужна только для чсв самого работника в
качестве нематериальной мотивации. В некоторых организациях еще для того, чтобы
выполнять формальные критерии повышения заработной платы.  Опыт прошедших лет
никуда не исчезает, просто вы еще не видите что из него котируется на рынке, а
что — нет. При смене языка так или иначе смотрят на предыдущий опыт человека.
Падение в зарплате — штука серьезная. Но вы ведь знаете свой базовый минимум для
жизни. Думаю вы его получите независимо от лычки. Вот если бы вы писали на f# и
typescript, а также жили бы в кредит, то это действительно стало бы
проблемой.0xd34df00d0Этих градаций на самом деле две — одна на бумаге и беджике,
другая в голове. За первой я особо не слежу, а вот вторая важнее-интереснее. И
туда входит то, что я знаю, что могу решать разные сложные проблемы, и то, что
ко мне обращаются за код-ревью или когда есть какой-то вопрос с заковыкой по
плюсам, и прочие тому подобные вещи. И терять вот это уже как-то менее приятно.
Ощущение статуса там где-то рядом.akryukov+4Вам действительно нужны эти сложные
задачи, которые возникали на плюсах?  Судя по статье, главная сложность была в
самом языке.  Со сменой специализации вы сможете заниматься настоящими сложными
задачами, а не маневрированием вокруг UB.0xd34df00d+1О, а это вы хорошо вот
сейчас заметили.С этими плюсами мне скорее кажется, что я и настоящих сложных
задач-то не нюхал.akryukov0В таком случае можно воспринимать это как ваш
привычный вектор развития вглубь. Просто вы переходите от простых задач к
сложным, на следующий этап, который не зависит от
языка.vassabi00xd34df00d0Поумнеть хотя бы даже на время было бы
неплохо.lamerok+1Эка печалька на вас напала :) Я думаю, что язык сам по себе
должен быть просто инструментом. Это типа как рисовать карандашами или в супер
пупер программе на компьютере.  Поэтому я бы вообще не стал зацикливать на
языке, возможно надо пойти в исследователи, где язык (да тот же Питон) нужен для
того, чтобы что-то изобрести, проверить, узнать.  По, моему опыту (в основном
микроконтроллерному) можно писать довольно простые и эффективные программы без
знания всех 1500 страниц стандарта, из которых 1490 никогда в жизни не
пригодятся. Но вам удачи конечно! Ваши статьи очень интересно читать!
0xd34df00d+2Можно, кстати, в обратную сторону. Писать какой-то тулинг для
плюсов, статические анализаторы какие-нибудь, не знаю. Там, опять же, и умение
листать стандарт полезно, но и писать все эти вещи можно совсем не на плюсах.Ну
я тоже так когда-то думал. А потом оказалось, что эти вещи всё же иногда
выстреливают.Спасибо! Буду стараться продолжать писать.vladkorotnev0Возможно,
лучше когда выстрелят, тогда и начинать их курить, чем заранее забивать голову
неврозом на тему стандартов вместо конкретной задачи. Слона нужно есть по частям
:-)0xd34df00d0Их не всегда можно курить, когда они выстрелят, потому что
выстреливают они иногда очень скрытно и с тяжёлой отладкой. Проще стараться не
допускать ошибок.vladkorotnev0Да, но сколько таких случаев было на практике,
когда оно реально выстреливало?  Зависит от сферы, конечно, если писать какой-то
суровый эмбед на базе MISRA, то да, лучше выучить всё заранее.Gorthauer870Ну вот
музыканты к примеру все равно имеют какие то любимые инструменты, хотя могут
играть и на любых других почти. Но все равно лучших успехов достигают там, где
ощущают, что это их родной инструмент. С программированием думаю точно все
также. lamerok0Согласен, но в любом случае, если есть предрасположенность к
этому, то в принципе играть можно и на акустической гитаре и на электронной или
даже на балалайке (ну возможно любимый будет). А у кого их нет — тому знание
инструмента не поможет.KanuTaH+30xd34df00d0А выгорание в том, что ты любишь,
любишь, любишь язык, как-то уже всю профессию с ним ассоциируешь, а потом всё.Ну
я начал туда шагать. Формальное PhD в Штатах, впрочем, требует GRE, которое мне
лень вспоминать-сдавать, так что я пока начал с обходных путей. Посмотрим, что
получится.KanuTaH+40xd34df00d+2Ну так фронтендеры справедливо бомбят же,
насколько я могу судить. По крайней мере, со стороны выглядит, будто эти новые
фреймворки ничего принципиально нового не дают, так что это это как раз
понятно.Как ещё одна библиотека эффектов в
хаскеле.KanuTaH0funca+2KanuTaH+4PsyHaSTe0С другой стороны есть раст который на
стаковерфлоу который год берет приз зрительских симпатий… И непонятно, то ли
радоваться, то ли нет.smarthomeblog+2tuxi–10xd34df00d0Так я и на других языках
уже довольно давно пишу, но там такого нет. Да, там есть свои проблемы, но при
одной мысли о том, что их сейчас придётся снова решать, не сводит пальцы. Думаю,
если бы я те же задачи решал на других языках, было бы сильно веселее.А с
вектором движения вообще всё сложно.funca0xztau0picul+40xd34df00d+2Ну, о том,
как работает CPU, я тоже какое-то представление сформировать успел.На самом деле
такие комменты позволяют лучше понять, что очень большая часть времени и сил
уходит на преодоление проблем инструмента, и что это на самом деле
проблема.picul00xd34df00d+4Потому что это фрактал плохого дизайна UB и
неочевидных мест.Я вот, например, таки вот совсем недавно узнал, что memset
нельзя (как написано в посте). Или вот потратил два дня на то, чтобы написать
маленькую фигульку, которая представляет заmmapленную память как int или тому
подобный тип, хотя кода там на 100 строк, включая RAII для файлового дескриптора
и mmap.Или, с другой стороны, у меня не так давно ушёл день на то, чтобы
починить что-то вродеИнтересно, какому числу людей проблема здесь сходу
видна?Или вот как в C++ до 20-ой версии эффективнее всего зафорвардить аргументы
в capture list лямбды? Никак, пиши костыли. Как захватить вариадик пак до C++20?
Никак, пиши костыли.Или вот когда вообще нужен синтаксис
std::forward<F>(f)(something) в контекстеKanuTaH00xd34df00d0Понятно, что это на
той стороне спектра, которую никогда не сломают, несмотря на формальное
несоответствие стандарту, примерно как union-style cast, поэтому я и написал «Но
на практике, конечно, всем пофиг.» Хотя и в этом я не уверен — проверка this на
nullptr не имела смысла вообще никогда, но код с ней был на практике (ЕМНИП чуть
ли не в MFC), и та же LLVM стала пользоваться UBшностью, кажется, в 9-м релизе.С
другой стороны, всё время вживаться в роль разработчиков компиляторов (причём
как минимум двух разных) и думать, сломают ли это когда-нибудь или нет, можно ли
полагаться на текущее поведение или нет, тяжело.А потом у нас при апгрейде
компилятора код ломается, и на C++11 вы переходите в 2016-м или 2017-м
году.funca0KanuTaH00xd34df00d+4Ну вот и мне не было понятно, и ещё этак пяти
человекам, через которых этот код прошёл.А разгадка одна — Base_t::Base означает
injected name в контексте Base (или какой там правильный standardese для этого)
— то есть, это тип Base<Derived<T>>. Если вы сделали алиас для базового класса,
то к его конструктору надо обращаться как using Base_t::Base_t;.gcc некорректно
принимает этот код, clang корректно его
отвергает[https://wandbox.org/permlink/opJPTXNtKWk98KAK]. Эта проблема вылезла,
когда я адаптировал кодовую базу к clang'у, и это был достаточно
распространённый паттерн в кодовой базе. Учитывая, что в реальности это был
класс где-то в середине иерархии «наследования» (вы абсолютно правильно сделали
вывод про полиморфизм), то есть, где-то в середине инстанциирования нескольких
десятков шаблонов, что приводило к тому, что ломался вообще весь код,
использующий этот класс, шаблонных параметров было не 1, а с пяток, и таких
случаев было много, а я с этой особенностью не был знаком, попытка понять, что
тут не так, включая построение MRE, заняла у меня несколько дней. Ну и плюс день
на то, чтобы пробежаться по всей кодовой базе и починить.И так каждый
раз.picul00xd34df00d+3Код с forward написан не мной, а чуваком, который хаскелем
и вообще ФП максимум интересуется, но не такой упоротый по этому всему, как я.
Просто способ изолировать ответственности и избежать дублирования кода.А forward
нужен, да. Достаточно всего лишь вспомнить, что operator() может быть
&&-qualified. Ну, типа, operator() && { /* текущий объект всё равно не нужен,
можно его затирать */ }.picul00xd34df00d+1mayorovp0Ну нет. В отличии от malloc,
функция mmap не входит в стандарт языка, а потому является всего лишь внешней
функцией. А поскольку ABI внешних функций никак не зависит от объектов и их
рантаймов — мы эти самые рантаймы можем додумать произвольно.0xd34df00d0Но это
чисто сишная функция, она физически не может знать про плюсовые рантаймы.
Поэтому достаточно умный (и ненавидящий пользователя) компилятор может этим
пользоваться, наверное.mayorovp0Нет, не может. Поскольку он ничего не знает про
эту функцию, даже то что она сишная — он обязан думать что эта функция корректно
начинает рантайм объекта.UB оно такое — если есть хоть малейшая возможность, что
его не произойдет — компилятор обязан считать, что его не произойдет. А для mmap
таких возможностей куча, начиная с банального return new int внутри, и
заканчивая placement new в другом процессе.0xd34df00d0А почему он ничего не
знает? Вот собираете вы код так, что он видит, что mmap берётся на glibc, и на
вашу систему LD_PRELOAD не звезли (а если завезли — так и memcpy, и malloc
сломать можно, но это не повод). Где-то внутри у компилятораЧему это
противоречит?О, а тут я совсем не знаю, валидно это или нет с точки зрения
плюсов.Akon32–1"Лайфтайм" имеет какое-то C++-специфичное значение? Borrow
checker завезли?  Так-то время жизни значения не зависит от того, что какая-то
функция получила на него ссылку. Ну хотя бы потому, что любые 32 или 64 бита —
валидное значение int, поэтому, что бы ни было записано в области, на которую
возвращён указатель, это будет совершенно корректный int (который, возможно, был
инициализирован вообще другим процессом, а затем записан в файл, который читает
mmap). Надеюсь, стандарт C++ ещё не дошёл до того, что значение по любому
указателю считается неинициализированным? Или уже пора проверять стандарт на неп
ротиворечивость?iliazeus+1https://eel.is/c++draft/basic.life[https://eel.is/c++d
raft/basic.life]Лайфтайм определен для
объектов[https://eel.is/c++draft/intro.object] в смысле модели памяти C++, и для
ссылок на объекты.Я не смог найти в
стандарте[https://eel.is/c++draft/basic.fundamental] подтверждение этому.
Например, похоже, что имплементация имеет право сказать, что int занимает в
памяти 64 бита, но старшие 32 — всегда либо все 0, либо все 1.Если он не
указывает на object — его нельзя разыменовывать.Если он указывает на object, у
которого еще не начался или уже закончился lifetime — с ним можно делать только
очень ограниченное число вещей (https://eel.is/c++draft/basic.life#6.4[https://e
el.is/c++draft/basic.life#6.4]).Akon320Параграф 4 не про это? Немного уточню:
под 32/64 бита я имел в виду 'width' из стандарта, т.к. почему-то думал, что
ширина в битах строго соответствует размеру в байтах очевидным образом.
Оказывается, стандарт разделяет эти понятия.Если какой-то указатель передан в
функцию void f(int *p){}, то непонятно, указывает ли он на int, и следовательно
непонятно, можно ли его разыменовывать без UB. Следует ли, согласно текущему
стандарту, подразумевать UB в каждом таком
случае?KanuTaH00xd34df00d0Правильно.Опыт показывает, что про это многие
забывают.KanuTaH00xd34df00d0Ну вот мы там все дружно писали библиотеку для
других отделов, и все люди там были очень умные, читали блоги, пропозалы и
guidelines на ночь. Но вот практика, блин...funca00xd34df00d0Только из всего
этого кода за моим авторством было только mmap. Остальное писали люди, которые
функциональщину в лучшем случае в вузе 10 лет назад видели.Если бы я писал код
под воздействием функциональщины, там были бы функторы и монады, и получился бы
кусок boost.hana.mayorovp0А в последнем случае не лучше ли было написать
std::invoke(std::forward<F>(f), something)?0xd34df00d0В обобщённом коде — да,
это заведомо лучше. Но это был условно теоретический вопрос за ланчем по мотивам
совершенно необобщённого кода, который никогда бы ни с чем, кроме лямбд, не
работал.funca+1Выгорание и С++ это две разные проблемы. Говорят, что первое
решается. Отдыхом, режимом дня, здоровым питанием, прогулками на свежем воздухе,
физухой, сменой обстановки, новыми амбициозными вызовами. Учитесь слушать свой
организм, а не только лекции по математике. Про второе я не уверен). Можно лишь
поменять свое отношение к языку и своему ремеслу. Язык как материал. Мастерство
гончара состоит в том, чтобы из куска г лины делать если не произведения
искусства, то максимально полезные или ценные вещи. С++ самый что ни на есть
говноязык с упопротым комитетом, грудой легаси и кастылей. А значит вполне
подходит для того, чтобы оттачивать свое мастерство и писать шедевры. Вы не
находите?0xd34df00d0Не думаю, что я выгорел в программировании вообще. В конце
концов, вот три месяца сижу дома, пишу код и не понимаю, как это тут люди пишут,
что им на карантине нечем заняться.Делать красивые фекалодендритные конструкции
на самом деле тоже прикольно, я это люблю. Выйдет C++20 — я таки возьму один
старый проект и перепишу его на концептах и вот этом всём, посмотрим, что
получится. Но писать продакшен-код, от которого что-то зависит — нет,
увольте.Antikiller+4Fedcomp0Ваш опыт и опыт множества ваших коллег начался с 12
летнего возраста?)overtest+7KanuTaH+1PeterAlmazov0moncruist00xd34df00d+1Ну,
четыре года назад я активно писал всякое машинное обучение и NLP на плюсах, три
года назад позанимался распределённой частью машиннообучательных систем, чуть
меньше года назад ушёл из большой-стабильной компании в маленькую с лоу-летенси
и вот этим всем, и при этом у меня на фоне последние лет 14 есть один большой
проект, с десктопом, кутями и гуями, да какой-то шаблонной наркоманией по мере
сил. И каждый раз меня бил язык.С другой стороны, я вот пару месяцев назад начал
пилить другой проект для себя не на плюсах (тайпчекер для игрушечного языка плюс
его компиляция в другой язык) и это просто небо и земля по сравнению с плюсами
(в очередной раз). Надо описать типы для языка — беру и пишу, без бойлерплейта,
без эмуляции ADT через std::variant, без ручного определения операций сравнения,
хеширования и распечатки. Этот же код можно будет почти без изменений вставить в
публикацию по языку, если что, там нет оверхеда. Надо распарсить — я просто беру
и пишу парсер. 40 строк, и всё готово. Тесты — одно удовольствие. Property-
based-тесты — тем более. Надо решать SMT-задачи при тайпчекинге — я просто беру
и добавляю z3 в список пакетов и дёргаю солвер через уже готовые байндинги. На
плюсах было бы больнее, хотя Z3 на них написан.Хороший язык не мешает решать
задачи и не возникает.Да ладно, какое уж там «идеально». Я просто не хочу, чтобы
меня разбудил pagerduty в три ночи, или чтобы из-за меня фирма потеряла
деньги.Энивей, спасибо за комментарий. Чем больше я читаю такие, как ваш, тем
больше убеждаюсь, что не надо бояться забить на хорошие предложения на плюсах и
пойти хотя бы попробовать делать что-то новое, к чему сейчас лежит
душа.Sofrony00xd34df00d0Пробовал в одну из, собственно, это одна из упомянутых в
конце поста хороших компаний. Просто Java и Go — тоже не предел мечтаний, да и
вообще там свои проблемы есть (например, фиг вы позанимаетесь личным
опенсорсом).В Microsoft Research вот не пробовал, но у меня там не с алгоритмами
проблема, а с PhD и субъективно слабой базой для того, что мне интересно. Нафиг
я им там нужен пока что, надо с чего попроще начать.Sofrony00xd34df00d0Очень
мало компаний занимаются достаточно близкими к моим текущим интересам проектами.
По крайней мере, насколько я могу судить со стороны.А у меня нет цели сделать
готовый к продакшену продукт. Мне просто охота, если в субботу вечером пришла в
голову какая-то идея, вот прямо сразу сесть, покодить по фану и сразу выложить
результаты труда да обсудить их в ирке/телеге/на реддите, а не ждать неделю-
месяц-два, пока отдел интеллектуальной собственности не согласует очередную
маленькую фигнюшку.AnthonyMikh0А вот это вы зря. Вы бы всё же попробовали, вдруг
им именно такой человек и нужен.Sofrony00xd34df00d0Технически хорошие статьи
заменяют PhD (вон, SPJ до сих пор без PhD ходит), но, думаю, они должны быть
более-менее по теме, а мои вузовские публикации по нелинейной регрессии максимум
показывают, что я умею их писать, и к логически-теоретико-типовым задачам
отношения не имеют, увы.0xd34df00d0Я пока начал действительно с контор попроще,
а там посмотрим, как будет получаться.Sofrony00xd34df00d0Всякое формально
доказуемое, плюс теория типов, формальная логика и тому подобные вещи. Целиком
понять жираровские «Proofs and types» было бы интересно, но мне не хватает
матана. Где-то рядом с теорией типов и Карри-Говардом верификация программ, где-
то рядом с теоркатом их синтез.Из практически применимых вещей, которые могут
быть мне относительно доступны сегодня-завтра — ну вот, например, посмотреть,
что нужно сделать с хаскелем, чтобы выделить там какое-то тотальное
подмножество.Как я докатился до жизни такой — ну, даже просто ковырять теорию
типов прикольно, писать на идрисе и доказывать вещи приятно, понимать, почему те
или иные вещи доказуемы (или недоказуемы), и почему те или иные термы тайпчекер
принимает только в том или ином виде, вообще мурашки по
спине.Sofrony00xd34df00d0Они как раз не сильно попроще :) JetBrains Research
делает прикольные вещи.Увы, я как раз сейчас не в России, что как-то иронично
даже получается. Кого-то вокруг них спрашивал не так давно — как я понял,
удалёнку они не очень любят.Sofrony+1Jef23900xd34df00d+3Jef2390yleo0В монастырь,
батенька. В монастырь.crea7or00serg+3PsyHaSTe+2Зависит от человека ведь. Мне
наоборот, не сильно важно чем занимается компания, в которой я работаю, но куда
важнее какие люди, какие возможности по изменению процессов/использованию
подходящих технологий у меня есть, и так далее. А рекламный бизнес это, блокчейн
или логистика — совершенно неважно, буду стараться вникнуть в бизнес насколько
смогу, главное чтобы по остальным пунктам был порядок.0xd34df00d+1Ну просто UB и
выстреливание себе в ноги околоUBшными способами убивает (UBивает?) больше
всего. Обращение за границы массива — это тоже UB, если что (с точностью до
терминологии, ill-formed/no diagnostic required не то же самое, что UB, и там
есть связь с проявляемыми рантайм-свойствами программы, но это неважно). Иногда
эти выстрелы очевидны, и кивать на слишком сложный стандарт даже не приходит в
голову. Но иногда приходится дебажить код несколько дней подряд, и оказывается,
что проблема в каком-нибудь хитром поведении компилятора на коде, который был
UB.Глюки компилятора? Были, но очень редко. За последние года три — ICE в
экспериментальных фичах компилятора (не считается по очевидным причинам, всё
равно оно в прод даже не думало идти) и креш в gcc 5.3 на дженерик лямбдах.
Всё.Кое-где, где я работал, тестирования не было вообще, либо тестирование было
уровня golden file testing. Ну вот мержите вы код из своей ветки в мастер, в
мастере всё работало, у вас всё работало, а смерженное начинает падать где-то
внутри. Успешной отладки.Кое-где тесты были, но они позволяли удостовериться,
что формальное UB компилировалось во что-то ожидаемое. И, где надо, были
комменты // !!! здесь потенциальное UB !!!.Собственно, тесты (особенно
интеграционные) — вовсе не панацея. Они лишь укажут, что система вдруг
(например, после апгрейда компилятора или библиотеки) начала падать. Почему она
падает? Хрен его знает. Сиди, дебажь.На TDD ресурсов не было ни в одном из мест.
Да и я бы тут поспорил с тем, адекватен ли язык, если из-за его особенностей код
надо покрывать TDD. В других языках юнит-тесты мне не нужны вообще, совсем, я
просто пишу интеграционные тесты на поведение системы в целом, и всё, этого
достаточно.Собственно, часть проблемы в том, что UBшность в каком-то смысле
неаддитивна. Функция foo сама по себе работает корректно, bar работает
корректно, а вот при их совместном использовании в каком-то определённом
контексте компилятор решает воспользоваться UB и что-нибудь заоптимизировать.
Тесты вам не укажут, что именно у вас сломалось.Проблемы разные бывали. Если бы
я их решал не на плюсах, то решать значимую часть из них можно было бы куда
эффективнее и проще.Так если б только я. Другие люди тоже любят. И это
оказывается оправдано. Потому что...Не в доли процента. Иногда это выгода в
несколько раз, особенно если код на hot path. А учитывая, что область такая, что
наносекунды действительно конвертируются в прибыль, и, как это, incentive,
стимул, короче, для людей делать так быстро, как только можно — большой и очень
ощутимый, люди и делают так быстро, как только можно.Но да, юзкейс узкий, не
спорю.Уверен. Там больше сильно больше трёх сценариев. Собственно, поэтому и
были разговоры о том, чтобы сделать какой-нибудь DSL с кодогенерацией того, что
надо, на чём-то более адекватном — это было действительно нужно.Я тут буду по
факту спорить сам с собой, но eigen с mkl делает какое-нибудь SVD-разложение или
псевдообратную матрицу на порядок-полтора быстрее, чем чистый eigen.Вы правы,
незачем. Поэтому, как только я первый раз сказал себе «да ну нафиг эти плюсы», и
небеса не разверзлись, жить стало лучше.Прикольно, у меня это как раз по
совокупности одна из наименьших болевых точек в плюсах. Даже без всяких
конанов.0serg00xd34df00d+1Особенно когда у вас код написан типапотому что
компилятор не осиливает оптимизировать обращения через container напрямую.Да,
нестабильность и непредсказуемость оптимизаций — ещё одна боль, но не мне из
моего хаскель-лэнда про неё вещать.Не, понятно, что есть asan, который это
ловит, но если у вас проект такой, что размер его хипа — десяток-другой
гигабайт, если не сотня, то asan там не поможет, увы.Зато это достаточно
болезненно для того, чтобы об этом помнить и включать реакцию избегания.Осталось
ещё менеджеру проекта, тимлиду и прочим подобным людям в это поверить. Там
golden testing было прорывом, а вы про юнит-тесты и TDD.Ну вот в одном моём
проекте, где есть большой файл на 300 строк[https://github.com/0xd34df00d/refine
dt/blob/master/toy/src/Toy/Language/Solver.hs] с не самой очевидной логикой,
юнит-тестов нет. Есть что-то типа интеграционных тестов[https://github.com/0xd34
df00d/refinedt/blob/master/toy/test/T20TCSpec.hs], что ожидаемый ответ главной
функции модуля совпадает с реальным на каких-то входных данных, и всё, этого
хватает. Надо было недавно кое-что отрефакторить — взял и отрефакторил, как
только тайпчекер пропустил код, тесты стали зелёные.Потом понял, что xor там в
одном месте зря, это очевидный бред, понял, какой тест эта система целиком будет
проваливать — починю и допишу этот тест. Юнит-тесты там особо не нужны,
ИМХО.Компиляторы очень паршиво делают автовекторизацию, я не удивлён. Но у меня,
опять же, минимизировать надо не throughput, а latency. Throughput, в конце
концов, можно потушить железом, а latency не получится. Накидать по ядру на
мультикаст-группу дёшево, а накидать ядер, чтобы один пакет обрабатывался не за
100 нс, а за 50, как-то труднее.Кстати, забавно, но dlib'овский pinv куда
быстрее, чем самописный костыль для определения псевдообратной через SVD, но
вычислительный линал — не моя сильная сторона, мог накосячить. Да и сравнивать
dlib и eigen как-то так себе.А, ну да, expression templates, классика :) Помню,
году в 2005-м кто-то ими понтовался, кажется, в blitz++ или чём-то таком, мол,
что плюсы обогнали этот ваш фортран в традиционной вотчине фортрана.Конечно.
Просто оказалось, что если не рассматривать всякое лоу-летенси, которое в хобби-
режиме делать трудно, то лично мне плюсы как-то совсем
незачем.F0iL+10serg00xd34df00d+3На самом деле даже такое бывает. Раскладка
адресов другая, не приводившие ранее к падению обращения по висячему указателю
или за границу массива стали что-то портить (или в лучшем случае выходить за
границу страницы), и всё.0serg0F0iL0Akon320Увы, это так не в 100% случаев. В
100% будет только при условии, что тестирование происходит на всех возможных
значениях входных данных.khim+10serg00xd34df00d+2Вот здесь проблема.Случаи,
когда тесты проходят, а всё вместе не работает (или падает на проде через три
дня работы), у меня были. Последняя проблема на практике чаще всего решается
через «а давайте просто будем каждый день перезапускать
сервис».0serg0PsyHaSTe0Как не бывает? Я всегда думал что undefiend значит
"неопределенное", значит вы тупо по определению не знаете, что с уб
"бывает".Vlad8000ZaMaZaN4iK+1KanuTaH+5ZaMaZaN4iK00xd34df00d0Искренне завидую. У
меня это осознание сломалось и стало обратным где-то в районе второго-третьего
пункта пути.Жалко, что cppnow 2020 отменили, кстати.ZaMaZaN4iK0PsyHaSTe0На раст
смысл свалить кмк довольно существенный (компилятор помогает, уб по факту
отсутствует как класс, если поблюдать пару простых правил), ну и на
идрисе/хаскелле писать в проде совершенно несложно, сложнее найти работу где
этим занимаются (но и такие места есть, хотя их и
мало).ZaMaZaN4iK00xd34df00d+1Ну что-то значимое на идрисе сейчас ни у кого нет
шансов написать, ИМХО (там даже пакетные менеджеры фиг пойми как работают, надо
сделать четвёртый). На хаскеле лично я успешно писал и пишу в прод, офигенные
ощущения.На конфе мне в 2019 понравилось :]ZaMaZaN4iK00xd34df00d0Я там в один из
вечеров после ужина кулстори всякие травил среди нашей русскоязычной тусовки, из
которой в итоге остались трое :]PsyHaSTe+6Мне кажется, тебе действительно надо
идти в разработку на Haskell минимум, а лучше на каких-нибудь коках и агдах. Или
в жетбрейнс пилить arend. Или ещё куда-нибудь. 17 лет плюсовика — ну и что? У
меня не такой обширный опыт, меньше 10 лет сишарпа. Но я довольно активно думаю
переметнуться в скалисты или растовики. Сижу, читаю Брэди, в закладках лежит
книжка по оптикам и теоретико-категорные обоснования для таглес файнала. Как это
помогает в разработке на сишарпе? Ну, у меня 0 мутабельного состояния в
приложении (не считая БД), ну и проверки на нулл вынесены на тайплевел. В
остальном — сплошные страдания, что вот этого сделать нельзя, того тоже нельзя.
Казалось бы, сам себе хуже сделал.Но нет, я не планирую и дальше страдать.
Работе люди отдают половину сознательного времени, это прям очень дофига чтобы
тратить его на ерунду. Зарабатывать х2 по рынку чтобы потом тратить свободное
время на езду по психологам и какие-нибудь расслабляющие филлеры? Зачем оно
надо. Надо заниматься любимым делом, даже если оно не приносит сверхприбылей.
Но, мое мнение, что если отдаться своему призванию, в большинстве случаев
деньгами тебя тоже не обидят.Когда я захожу на хабр и у меня в подписках
показано что ты написал статью, я первым делом думаю про "О, тот классный
хаскеллист-байтокрут что-то написал". И ни разу я не подумал "О, тот сениор-
плюсоид что-то запостил". Самоидентификация у тебя такая, а со стороны выглядит
совсем иначе. И как знать, возможно со стороны виднее.Иди в те математики-ученые
про которые ты говоришь. Блин, тебе даже 30 нет, а ты жалеешь о каком-то опыте
который потеряешь. Максимум, что ты потеряешь — забудешь как по отсвету дула
определять цвет ноги, но это бесполезный опыт. Затачиваться под него, все равно
что работать годами в банках — деградация как специалиста, зато зарплата в
полтора раза выше чем по рынку, и вместо работы можно фигнёй страдать, с той
бюрократией что там есть никто и не заметит. Каждому — своё, у меня куча
одногруппников по банкам расселилась, но я физически например не выношу такое.
Почитай как люди в 35+ приходили в айти вообще с другого конца: врачи, физики,
всякое такое. И ничего, живы-здоровы, зарабатывают и довольны. Тебе же насколько
я понимаю интересна та же разработка, только в профиль — чуть больше
формальности, пейперы там всякие, академики. Ну блин, не так уж это сильно
отличается от твоего профиля. Да, что-то придётся подучить, математику
подтянуть, возможно. Но есть подозрение, что ты сам себя накручиваешь, и что
эффект данинга-крюгера не дает тебе признать, что ты не только сениор-плюсоид,
но и просто классный специалист широкого профиля.0xd34df00d+1Спасибо! Такие
комментарии помогают думать, что я по крайней мере статьи пишу не зря, да и
вообще всё это вполне может иметь смысл.С заработком тоже интересно. Вот,
например, думать ли о работе, где платят ×2.5 от моей позапрошлой зарплаты,
которая уже сама по себе была сильно выше рынка, но где надо просто фигачить
плюсы? С одной стороны — можно за год-полтора купить дом, а за следующие год-два
скопить на остаток жизни, и уж тогда ресёрчить-ресёрчить в свое удовольствие.С
другой стороны, я уже потратил лет 6 на «вот сейчас позанимаемся ерундой, и уж
тогда…» Наверное, стоит начинать делать что-то осмысленное, наконец.Короче, да,
спасибо, это всё склоняет чашу весов в пользу интереса, а не какого-то не пойми
какого планирования непонятно чего.В одном околобанковском месте мне полгода
было нечего делать, то есть, буквально полгода не было проекта, и я там как раз
практиковался в каких-то хаскелевских вещах.PsyHaSTe0Тоже думал поработать на
одной галере с ужасными условиями, но х2 от моего оклада. Решил, что не стоит
того. Это ведь процесс бесконечный. "Щас на дом накоплю и уволюсь. Щас на яхту
накоплю и уволюсь. Щас на самолёт накоплю и уволюсь. Щас на универ сыну накоплю
и уволюсь..."anton19286+1bgnx0Хорошая статья. Нечто подобное (но со стороны куда
более простого языка) было и у меня. Некоторое время назад я считал что знаю
javascript (как никак больше 6 лет на нем пишу) а потом открыл спеку и просто
ужаснулся от того огромного количества нюансов, особенностей, моментов и
разнообразных языковых конструкций про которые я до этого был не в курсе. И
такое чувство что нужно не какие-то там десять-пятнадцать лет опыта — тут нужно
быть разработчиком движка чтобы можно было сказать что знаешь js (хотя я не
уверен что разработчики v8 знают наизусть все детали спеки). И знаете что
помогло мне преодолеть этот страх от неизвестности и сбросить с плеч тот груз
безысходности и необходимости всю остальную карьеру подучивать какие-то нюансы
языка как какой-то там "вечный студент"? Я просто взял и написал свой парсер
который парсит по белому списку лишь необходимое мне подмножество языка
отбрасывая все те избыточные и переусложненные нюансами конструкции и фичи языка
которые понапридумывали укуренные авторы спеки (и продолжают придумывать с
каждым годом не считая то количество разнообразных пропозалов и stage0 фич). В
итоге я не стал лучше разбираться в каких-то там нюансах языка — я просто
перестал беспокоится о них так как в коде который я пишу эти нюансы и
конструкции просто больше никогда мне не понадобятся и соотвественно скрытых
нюансов просто быть не может так как мой парсер парсит все по белому списку
нужных мне конструкций, нюансов синтаксиса и фич в которых я
уверенprintf+20xd34df00d0О, веб-ерунда.А как сейчас в вебе со старыми
браузерами? А то лет 18-19 назад, когда я вот прям совсем-совсем начинал, и у
меня не было компилятора плюсов, а был комплюктер с notepad.exe и IE5, а также
учебник хтмла на диске «Подводной Лодки» (удачно номер купил, конечно), тогда
все очень переживали за совместимость с браузерами N-летней давности,
рекомендовали не использовать CSS/div/чётамещё. И году в 2008-м тоже ещё было
слышно «ну да, свежий IE, Opera и FF это умеет, но не умеют все прошлые браузеры
за последние 10 лет, поэтому используем jquery».А сейчас вышел какой-нибудь
флексгрид — фигачим в прод! Вышел ES100500 — используем! Или это просто по
хайповым статьям не надо судить?Эх, босая моя юность, снежинки за мышкой,
document.write() и 15 баксов за какой-то говносайт про гербалайф на
народе.KanuTaH+1vladkorotnev0Во многом с такими вещами полифиллы помогают. Это,
условно говоря, реализация новых фич на базе старых в тех браузерах, которые в
них не умеют. Эдакий Win32s новой эпохи, и работает в принципе по качеству так
же.VolCh0Люди радуются, когда на их проекте отказываются от поддержки IE.
norguhtar0Решается специальными прокладками. В итоге начинаем собирать
приложение в web специальным упаковщиком. Зато можно не заморачиваться про
совместимость. Почти :)hellamps+2А теперь подумайте что рядом с вами люди пишут
код на джаваскрипте в продакшен, и они, поверьте, не только шаблонов, но и
многого другого не видали.Вообще по уровню возможных хаков JS настолько впереди,
что я даже не знаю, есть ли еще такой язык :)Amomum+1Тут уже многие писали что-
то подобное, но я все же добавлю свои пять копеек.  У меня прямо вот те же
ощущения от С++, но только опыта поменьше и дым пожиже :)Я спрятался в embedded,
где значительной части проблем нет (взамен, конечно, есть свои, другие
проблемы!), но зато нет и особого выбора — только С и С++. Ну Rust, да, да, но
там еще жить да жить до полноценной поддержки сообществом.У вас же есть
достаточно широкий кругозор в других языках, в разных задачах и областях. И не
надо думать, что опыт на С++ вы просто отбросите — нет, совсем нет! Опыт "как не
надо" он бесценен практически :)  Не знаю, как вы, но я пока что все остальные
языки "мысленно перевожу" на С++, только так я себе могу объяснить и типы
высшего порядка и трейты. Не представляю, как рассуждают люди, которые сразу
учили Хаскель.В общем, советы-то от выгорания простые — сделайте паузу, не
заставляйте себя гореть еще сильнее, ищите дело, которое вам нравится. И да, я
думаю, что благодаря этой статье вы значительно легче найдете команду
единомышленников :)Короче говоря, не вешайте нос!Был я относительно недавно на
собеседовании (на позицию embedded-программиста), где меня попросили написать
аналог tar'a. С лимитом по времени 4 часа. И без Qt, пожалуйста.  Штош, подумал
я, где наша не пропадала?  1 час я потратил на установку boost'a (не встал,
какие-то жэсточайшие ошибки, не было времени дальше копать).  Еще час я
потратил, чтобы узнать, как кроссплатформенно открыть файл и узнать его размер.
Кажется, никак, если нет С++17 c std::filesystem.  Последний час я из спичек и
желудей лепил хоть что-нибудь.И вот потом я сидел и думал, что же с нами стало.
Вообще, С++ это словно какая-то игра, специально разработанная, чтобы вызывать
зависимость. Только не специально!KanuTaH0Amomum0Я в итоге так и сделал, если
правильно помню -_-'  Меня, как и автора поста, С раздражает тем, что все
вручную — но блин, ХОТЯ БЫ вручную!Но все же не хочу в С. Я уже слишком
развращен auto, constexpr'ом и шаблонами.P.S. Интересно, почему Vala не
взлетела, вроде вменяемая идея была.KanuTaH0Amomum0Ну типа того, да. Интероп
должен быть нормальный, компилятор готовый (та же идея, что и в Rust'e с
компиляцией в LLVM-IR, только на N лет раньше), сишная стандартная библиотека…
Хотя я особо глубоко не копал, а сейчас соображаю плоховато :)  Помнится, в Вале
даже импорт сишной функции как-то мерзковато выглядел.bgnx+1О, знакомая история…
У меня опыта с плюсами и си совсем немного но даже этого хватило чтобы вызвать
отвращение к возни с этими библиотеками (включая стандартную) и
кроссплатформенностью (с кучей враперов со своими нюансами над другими враперами
которые там где-то сводятся к системным вызовам). И я решил по-другому — раз мой
софт все равно будет работать на сервере (или в докере) в контролируем окружении
(только линукс, без тонны остального софта и сервисов всяких убунту-дебиан-
дистрибутивов — то есть только само ядро с моей софтиной в виде статического
бинарника в качестве pid0) — то в итоге без кроссплатформенности все стало
намного проще — у меня остался один источник правды в виде системных вызовов
линукса и я избавился от тучи нюансов стандартной библиотеки или других
врапперов и легко написал нужную мне софтину работы с файлами и сокетамиAmomum0Я
между делом решил, что в следующий раз просто буду брать Qt и никого не слушать;
с ним хоть как-то кроссплатформенно можно жить. Тоже больно, но уже в других
местах, не таких натертых.0xd34df00d+1Если бы меня попросили на чистых плюсах
работать с ФС, да за 4 часа — я бы, наверное, сразу сказал «давайте чем-нибудь
другим займёмся».ЧСХ почти везде, где я работал, были свои какие-то библиотеки и
вспомогательные классы для работы с ФС. Даже в тех кодовых базах, которые
начинались с C++17 и std::filesystem.Вот, кстати, сейчас знакомый товарищ
спрашивает в мессенджере, почему у него
SomeHeap<ElemType>::push_heap(ElemType&&) не работает в контекстеРассказал, что
надо делатьЕго реакция:  khim00xd34df00d0ИМХО enable_if имеет смысл, когда у
может быть другой push_heap с другим типом элементов. Здесь передача
неправильного типа элемента — жёсткая ошибка, надо о ней сразу и максимально
явно сказать.khim00xd34df00d0Ну а так у вас намёк тоже будет, просто на
следующей строке:или вроде того.Но в ваших словах тоже есть смысл, такое
сообщение на современных компиляторах, наверное, понятнее. На код ревью я бы оба
варианта принял, но если бы ревьювер предложил поменять, то я бы
согласился.TargetSan+1Вообще я в таких случаях пишу две перегрузки, ElemType
const& и ElemType&&. А сложную логику, независимую от метода форварда, кладу в
приватный метод. Чуть больше бойлерплэйта, но гораздо понятней.Amomum0Я подумал
— блин, ну я же прогромист, это же не может быть настолько сложно!  Не может же
быть, чтобы на языке, ориентированом в первую очередь на нативные приложения под
десктопы, нельзя было нормально открыть файл, это же нонсенс...Нет, стоп, надо
сдерживаться, иначе у меня сейчас тоже бомбить начнет -_-sibvic00xd34df00d0Вот
это прямо хард²!Наверное, я слишком (не) люблю языки. Даже если одну и ту же
задачу на разных языках решать — совсем разное настроение и
отношение.norguhtar0Да нормально. Поковыряться в автомобиле занятие прикольное.
Заодно очень хорошо лечит от перфекционизма :) Refridgerator+2norguhtar0Потому
что осознание наличия других вещей требует вылезти из своей зоны комфорта. А
коробочка программирования да еще такого узкого это очень удобно.norguhtar0Для
начала вылезти из коробочки с С++. Никогда не понимал людей которые занимаются
только одним языком. Да я скорее всего нуб в С++ по сравнению с автором. Но это
же рехнуться можно одним и тем же заниматься столько времени. Ладно хоть до
автора дошло это. Вообще лучше всего хотя бы в рамках хобби завести деятельность
никак не связанную С++, хоть не знаю заняться банальной электроникой, или вообще
старый автомобиль завести и читать про устройство и настройку карбюратора.
Перебирать карбюратор обложившись газетками и ветошью, что может быть более
умиротворяюще :)0xd34df00d0Так я не только на плюсах пишу. Просто как-то так
получалось, что это всегда было либо моим основным языком, либо одним из двух
основных.Это тоже есть. Книжки всякие занудные читаю, задачки оттуда
решаю.norguhtar0Учитывая сколько написано про C++ есть ощущение что он сжирает
90% основного времени работы. А это несколько дофига. Не книжки надо читать и
задачки решать, а именно поменять сферу деятельности. Перестаньте насиловать
мозг тем же самым. Попробуйте в том числе вещи которые не требуют приложений
большого числа мысленных усилий.big_hasan00xd34df00d0Да. Год-два проживу без
особых проблем уж точно.Ну я в школе на олимпиады по физике ездил, и не совсем
безуспешно. В вузе на общефизе тоже был одним из двух ответственных за домашку
на курсе :)Ну я сейчас вот математику ковыряю. Теория типов и логика отлично
заходит, всякий теоркат  — тоже неплохо. Конкретно сейчас в учебнике, что я
читаю, глава по конечным группам — скучно как-то, одно деление и индексы, и всё
(да и интуиции у меня там нет, чего врать), но это пройдёт.Почему, как раз
наоборот! Просто это такие, особые языки. Там, где эти языки действительно нужны
(а это всякий академический ресёрч зачастую), не хватает уже моих навыков.
Наверное. Я не то чтобы как-то очень пробовал.Просто я привык, что мне
шевелиться особо не надо для поиска работы, например. А тут шевелиться таки
придётся, по крайней мере, поначалу.Плюс, у меня есть пара знакомых, которые от
академии стали бы активно отговаривать. Фиг его знает, короче, что делать с этим
всем.big_hasan00xd34df00d0Отчего ж сплошные? Говорю ж — последние три месяца вот
код пишу для себя, никаких страданий, одно удовольствие. Просто, считайте, не на
плюсах.С одной стороны, и я не до конца понимаю, что там в черепушке происходит,
с другой — некоторые факторы и аспекты уж точно не соответствуют тематике хабра,
а нарочно делать из людей тут психологов вряд ли стоит.Kanut00xd34df00d0Вот
только, боюсь, до некоторых вещей из того, что я хочу, уйдёт не годик и не
два.Правда, наверное, не обязательно этих вещей отчаянно
ждать.Kanut00xd34df00d0На самом деле в первую очередь я хочу делать то, что
интересно и клёво, ну, для себя самого. А крутость, успех — это так, ерунда, в
лучшем случае индикаторы, что я более-менее на правильном пути (хоть терять эти
индикаторы и жуть как неприятно, ЧСВ они таки чешут).Чем больше я тут
комментарии всякие читаю, тем больше понимаю, что ответ-то на самом деле простой
— надо просто брать и делать вот то самое, что хочется. Но это почему-то
оказывается сложнее, чем я всегда
думал.Refridgerator0CrashLogger–1AlexunKo+10xd34df00d0Не уверен.По крайней мере,
не работаю вот почти три месяца, пока не устал.xztau–2mkvmaks00xd34df00d+1А нету
этой нормальной практики.Если вы возьмёте эмбеддщика, HFT-программиста,
машинного обучателя и десктоп-разработчика, то у них у всех будут свои (и вполне
корректные в их условиях) представления о прекрасном. Да и там ещё больше
измерений у задачи — пишет человек конечный продукт или библиотеки для других
программистов, на какой пул кандидатов-коллег он может рассчитывать, какие
сроки, какие требования к надёжности (эмбеддед-кардиостимулятор и эмбеддед-
датчик температуры в качестве хобби-проекта — совсем разные вещи) и так
далее.Artifeks+1Nomad100serg0Nomad10PsyHaSTe0Сложность языков ИМХО идёт в двух
направлениях: оперативная сложность и пассивная сложность. Первая — это то, что
нужно держать в голове постоянно, и быть на пределе концентрации: знать где УБ,
что пойдёт не так, и так далее. Вторая — пассивная, это академические знания —
понимать, что такое функтор, монада, что означает ошибка cannot construct the
infinite type: t ~ t1 и так далее. Пример языка с высокой первой сложностью и
низкой второй — ассемблер. В нем очень мало конструкций, но в голове надо
держать дофига всего, чтобы софт вообще работал.  Обратный пример — идрис какой-
нибудь. Там много чего нужно читать чтобы понимать что вообще происходит, но
если прочитал, то компилятор поможет снизить первую сложность до нуля.Возможно у
них есть какие-то другие названия, может подскажет кто. Интуитивно мне это
кажется как-то так.PsyHaSTe0C# и Java очень слабые. Ну как простой пример, они
даже не позволяют в интерфейсе статические методы объявить.Nomad10PsyHaSTe0Вы
читали другие статьи автора? Потому что у меня есть подозрение, что у него будет
та же реакция что и у меня: "какого хрена язык не позволяет мне выразить такую
простую вещь Х". Это нифига не круто, ловить из-за этого ошибки в
рантайме.Nomad10st0ke0PsyHaSTe0А можно пример? Что-то вроде:Как в джаве это
написать можно?st0ke–1TargetSan+1Я думаю, под static method имелся ввиду метод,
не зависящий от instance, но при этом перегружаемый. Идея в том, что интерфейс
определяет не просто полиморфное поведение инстанса, но контракт всего типа.
Например, добавляет сигнатуру метода-фабрики сразу в интерфейс. Такие фокусы
возможны в языках, где вместо интерфейсов живут трейты или тайпклассы. Haskell,
Rust. Golang позволяет подобный фокус неявно т.к. использует fat pointers и не
требует self-pointer != null. PsyHaSTe[https://habr.com/ru/users/psyhaste/] Я
подозреваю, в Java/C# такое невозможно по чисто идеологическим причинам. Там для
таких фокусов применяются инстансы фабрик.st0ke0Akon320Такое — абсолютно никак.
У вас в статическом методе, у которого нет объекта this, используется тип T из
объекта this.А вот это работает[https://onecompiler.com/java/3vrddwbxb]:korizza_
spb+1megaentwickler0kryvichh–1Я б никогда не смог работать на проектах, где
основная задача — выжать ещё 1мс в обработке очередной порции данных. Это
скучное программирование. VEG0tmaxx+1Конечно скучное! Веселье начинается на
микросекунде и ниже :)Vindex+1VEG0hard_sign–2Druu0Ну пора, наверное, перестать
быть "программистом на Х" и стать просто "программистом", тем более что у вас то
уж есть все пререквизиты и возможности для этого.А вообще, перестать получать
удовольствие от плюсодроча — это не выгорание, это взросление.prefrontalCortex0I
know that feel bro.Я сам давно соскочил с плюсов и в свободное от работы время
пишу на Common Lisp — по набору возможностей примерно всё то же, что в плюсах,
зато стандарт не менялся уже 26(!) лет, и меняться не собирается.Akon320Проблема
в том, что стандарт вырос настолько, что не влезает в голову. Любая
развивающаяся система со временем накапливает противоречия, о которых чёрт
голову сломит. Особенно языки программирования. Программирование сложно само по
себе, сложность языков только отражает сложность программирования, сложность
задач.  Имхо, излишний перфекционизм вреден. Очень трудно помнить весь стандарт
и вовремя обновлять знания. Но текущие задачи обычно этого и не требуют. Для
повседневных задач достаточно знать некое подмножество стандарта. Да, это с
учётом того, что незнание может (и будет) приводить к ошибкам в коде. Но ошибки
можно отловить другими способами, а иногда можно даже их оставить. Для того,
чтобы программа решала задачи пользователя, не обязателен идеальный код или код
без ошибок.  Для того, чтобы быть экспертом (консультантом), опять-таки, не
обязательно знать 100% темы. Достаточно знать больше, чем условные 99% остальных
пользователей.Я не могу советовать забить на изучение новых версий стандарта. Но
чтобы программировать, не обязательно применять весь стандарт. В смысле "если
memset работает — то и пофиг, что неправильно, код же работает". Писать код и
смотреть на написанный код станет легче. Отлаживать — возможно, сложнее, но
важен баланс.Ну вот же ответ:Совет "программировать, а не программировать на
конкретном языке", думаю, известен до банальности. К чему эта самоидентификация
"я программист на плюсах"? Так как знания и опыт вообще разработки есть, можно
сводить к более общему "я программист". Можно вообще отказаться от подобной
самоидентификации, т.к. области знаний, роли, профессии, занятия — это "трейты",
которые подключаются к личности, со временем их накапливается десятки, и
называть себя чем-то одним — становится скорее неверно, чем верно. Тут больше
подходит вопрос "Умею ли я программировать на плюсах?" (программировать на
хаскеле, в матан, играть на гитаре, etc), чем "Кто я?" (этот вопрос обычно
подразумевает лишь 1 ответ, что, по крайней мере в наше время, не соответствует
реальности)tommyangelo270Ну что тут сказать… Welcome to the club.
gatoazul0Riateche0tmaxx0У вас, насколько я понимаю, достаточно узкая
специализация по классу задач который вы решаете. Мне кажется дело в ней, а не
столько в С++. Очередной бложик или магазин можно написать и развернуть сотней
разных способов, из которых половина через год выйдут из моды и нужно будет
учить новые. Не соскучишься.А узкую задачу можно решить условно тремя способами,
из которых два неоптимальны в данном случае. Причём изменения ситуации не
предвидится. И конечно очень круто решить ее одним оставшимся способом,
посмотреть на красивые графики latency или ещё более красивые графики
доходности. В первый раз. Может быть в пятый. Но не в двадцать второй.К
сожалению, все выходы из ситуации подразумевают потерю существенной части дохода
на год-два. Либо искать другую узкую область. Там повторится то же самое, но
через 5-6 лет. Либо переходить в мастера на все руки (фулл-стек, облака,
Kubernetes, вот это вот все). То что нужно 90% заказчиков. Смена предметной
области очень помогает, и хорошо если ее можно делать регулярно. Либо завязывать
с программированием вообще, по сути — пенсия, retirement (по-английски звучит не
так обреченно :). Если есть достаточно накоплений на жизнь в красивой
европейской деревне — почему нет? И лучше закладываться на несколько вариантов.В
противном случае есть шанс через пару лет влиться в стройные ряды большинства, у
которых есть ненавистная работа (даже очень высокооплачиваемая) и любимое
хобби.Кстати, выше уже говорили, но хобби необходимо. Желательно связанное с
физической активностью. Мозг прочищается на ура. Опять же проблему полностью не
решит, но отложит на много лет. Если такого нет — обязательно попробуйте
несколько вариантов, может что-то «зацепит».На счёт перехода в науку — не знаю.
Нужно обладать очень специфичным складом ума, чтобы долбить в одну точку 15 лет,
а потом, если повезёт, открыть что-то такое, что понимает 20 человек в мире.
Некоторым нравится преподавание, но это можно делать и не в
науке.bayarsaikhan0Только полноправные пользователи[/info/help/registration/]
могут оставлять комментарии. Войдите[https://habr.com/ru/auth/login/],
пожалуйста.

Что обсуждают

                       4,4k
4,4k9                       8,6k                     8,6k11
30k                     30k337                       61,1k
61,1k344                       6,6k                     6,6k15
30k                     30k337                       27,5k
27,5k134                       21,7k                     21,7k105
14,6k                     14,6k69                       13,3k
13,3k33                       55,4k                     55,4k467
26,9k                     26,9k438                       61,1k
61,1k344                       30k                     30k337
83k                     83k247

Самое читаемое


&plus;196                     &plus;196                       30k
30k                       98                     98337
&plus;69                     &plus;69                       27,5k
27,5k                       81                     81134
&plus;125                     &plus;125                       21,7k
21,7k                       100                     100105
&plus;13                     &plus;13                       14,7k
14,7k                       9                     939
&plus;22                     &plus;22                       14,6k
14,6k                       41                     4169
&plus;176                     &plus;176                       83k
83k                       213                     213247
&plus;144                     &plus;144                       72,4k
72,4k                       192                     192173
&plus;86                     &plus;86                       62,7k
62,7k                       77                     77181
&plus;192                     &plus;192                       61,1k
61,1k                       38                     38344
&plus;75                     &plus;75                       55,4k
55,4k                       83                     83467
&plus;20                     &plus;20                       918k
918k                       221                     2212149
&plus;329                     &plus;329                       169k
169k                       291                     291643
&plus;101                     &plus;101                       115k
115k                       162                     1622333
&plus;176                     &plus;176                       83k
83k                       213                     213247
&plus;174                     &plus;174                       80,2k
80,2k                       195
19573

Рекомендуем



Сломать всё и прокачать безопасность. Скоро на шоу
«ИБшник на удаленке»



AR в музее глазами посетителей



       Ваш аккаунт




Разделы



Информация



Услуги

© 2006 – 2020
«TM[https://tmtm.ru/]»Настройка языка                                  Русский
English                                                 Русский
Английский